{"./":{"url":"./","title":"LeetCode with Python","keywords":"","body":"LeetCode with PythonLeetCode with Python 用Python解LeetCode，现在已经完成了100多道，但是很多都还没有完善分析过程。 之后我也会继续刷题和完善本Book，希望为大家的刷题过程提供一些帮助。同时也欢迎大家来我的博客看看。 http://xnerv.wang @3x3只眼 Welcome to my blob Xnerv Surveys "},"two-sum/":{"url":"two-sum/","title":"1. Two Sum","keywords":"","body":"【LeetCode with Python】 1. Two Sum题目分析代码【LeetCode with Python】 1. Two Sum tagsstart Medium Problems Array Hash Table tagsstop 题目 原题页面：https://leetcode.com/problems/two-sum/ 本文地址：http://leetcode.xnerv.wang/two-sum/ 题目类型：Array, Hash Table 难度评价：Medium 类似题目：(M) 3Sum, (M) 4Sum, (M) Two Sum II - Input array is sorted, (E) Two Sum III - Data structure design Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 分析 给定一个数列（注意不一定有序），和一个指定的数值target。从这个数列中找出两个数相加刚好等于target，要求给出这两个数的下标（注意数列下标是从1而不是从0开始）。 首先将数列排序。由于最后要得求的是两个数的原有下标，而不是两个数本身，因此要用一个新的对象Item来封装原有数列元素，并记录该元素的原有下标。排序是针对数列元素本身数值的，分别用一个index1指针和一个index2指针指向排序后的数列的首位，如果指向的两个数相加的和等于target，则搜索结束；如果和小于target，则由于index2此时指向的已经是数组中的最大数了，因此只能令index1向右移动一次；如果和大于target，则由于此时index1已经指向数组中的最小数了，因此只能令index2向左移动一次。用一个循环重复上述过程，直到和等于target宣告搜索成功，或者index1>=index2宣告搜索失败。 空间复杂度O(n)，因为构造了一个新的Item序列。时间复杂度方面，如果假设Python的sort算法是用的快速排序的话，那排序的时间复杂度为O(n*logn)，搜索过程的时间复杂度为O(n)，因此总的时间复杂度为O(n*logn)。 注意给的数列也许长度为0，这样无论target是多少都是搜索失败。而且题目中给的example明显是是在误导人，不仔细看误以为数列原本就有序。此外，数列下标是从1而不是从0开始的。 但是这种算法的前提要先进行一次排序，看起来总是有点不舒服，是不是有更好的算法呢？ （哈希表可以将时间复杂度降低到O(n)，另外好像编程之美中有这道题目？) 代码 class Solution: class Item: def __init__(self, value, index): self.value = value self.index = index # @return a tuple, (index1, index2) def twoSum(self, num, target): len_num = len(num) if 0 == len_num: return (-1, -1) items = [Solution.Item(value, 0) for value in num] for i in range(0, len_num): items[i].index = i + 1 items.sort(lambda x, y: cmp(x.value, y.value)) index1 = 0 index2 = len_num - 1 is_find = False while index1 target: index2 -= 1 else: is_find = True break (index1, index2) = (index1, index2) if items[index1].index Welcome to my blob Xnerv Surveys "},"add-two-numbers/":{"url":"add-two-numbers/","title":"2. Add Two Numbers","keywords":"","body":"【LeetCode with Python】 2. Add Two Numbers题目分析代码【LeetCode with Python】 2. Add Two Numbers tagsstart Medium Problems Linked List Math tagsstop 题目 原题页面：https://leetcode.com/problems/add-two-numbers/ 本文地址：http://leetcode.xnerv.wang/add-two-numbers/ 题目类型：Linked List, Math 难度评价：Medium 类似题目：(M) Multiply Strings, (E) Add Binary You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 分析 一开始还想复杂了，以为链表头是最高位，于是还准备通过递归来解决。后来才发现原来原来链表头就是最低位，于是这题目的难度就几乎为0了。注意进位的处理，尤其是最后可能的进位。 代码 class Solution: # @return a ListNode def addTwoNumbers(self, l1, l2): cur1 = l1 cur2 = l2 carry = 0 head = ListNode(-1) cur = head while None != cur1 and None != cur2: plus = cur1.val + cur2.val + carry digit = plus % 10 carry = plus / 10 cur.next = ListNode(digit) cur = cur.next cur1 = cur1.next cur2 = cur2.next if None != cur1: while None != cur1: plus = cur1.val + carry digit = plus % 10 carry = plus / 10 cur.next = ListNode(digit) cur = cur.next cur1 = cur1.next elif None != cur2: while None != cur2: plus = cur2.val + carry digit = plus % 10 carry = plus / 10 cur.next = ListNode(digit) cur = cur.next cur2 = cur2.next if None == cur1 and None == cur2: ###must after if and elif if 1 == carry: cur.next = ListNode(1) return head.next Welcome to my blob Xnerv Surveys "},"median-of-two-sorted-arrays/":{"url":"median-of-two-sorted-arrays/","title":"4. Median of Two Sorted Arrays","keywords":"","body":"【LeetCode with Python】 4. Median of Two Sorted Arrays题目分析代码【LeetCode with Python】 4. Median of Two Sorted Arrays tagsstart Hard Problems Divide and Conquer Array Binary Search todo tagsstop 题目 原题页面：https://leetcode.com/problems/median-of-two-sorted-arrays/ 本文地址：http://leetcode.xnerv.wang/median-of-two-sorted-arrays/ 题目类型：Divide and Conquer, Array, Binary Search 难度评价：Hard There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 分析 找两个有序数列的“中位值”。发现LeetCode上还是有不少坑。如，这个题目说的有序数列其实是从小到大排列的，不需要我们像处理其它经常埋坑的题那样“以小人之心度君子之腹”地去先检查A和B是从小到大还是从大到小，甚至有可能A从小到大而B却从大到小。其次，这个“median”并不是指“中位数”，而是“中位值”，两者的区别是：当m+n为奇数时，这两个词是一个概念。而当m+n为偶数时，中位数可以指按大小排在最中间的那两个数，而中位值则是指这两个数的平均数。何其坑哉！ 代码 class Solution: # @return a float def findMedianSortedArrays(self, A, B): len_a = len(A) len_b = len(B) len_total = len_a + len_b if 0 == len_total: return '' if 0 == len_a and 1 == len_b: return B[0] if 1 == len_a and 0 == len_b: return A[0] if 1 == len_a and 1 == len_b: return float(A[0] + B[0]) / 2 median_index = len_total / 2 is_odd = (1 == len_total % 2) index_a = -1 index_b = -1 median_num = 0 for i in range(0, median_index + 1): if index_a + 1 = len_b or A[index_a + 1] Welcome to my blob Xnerv Surveys "},"zigzag-conversion/":{"url":"zigzag-conversion/","title":"6. ZigZag Conversion","keywords":"","body":"【LeetCode with Python】 6. ZigZag Conversion题目分析代码【LeetCode with Python】 6. ZigZag Conversion tagsstart Easy Problems String tagsstop 题目 原题页面：https://leetcode.com/problems/zigzag-conversion/ 本文地址：http://leetcode.xnerv.wang/zigzag-conversion/ 题目类型：String 难度评价：Easy The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P---A---H---N A-P-L-S-I-I-G Y---I---R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\". 分析 下标计算处理，控制好循环条件，下标不要越界即可。 代码 class Solution: # @return a string def convert(self, s, nRows): if 1 == nRows: return s len_s = len(s) piece_len = 2 * (nRows - 1) result = \"\" index = 0 while index Welcome to my blob Xnerv Surveys "},"reverse-integer/":{"url":"reverse-integer/","title":"7. Reverse Integer","keywords":"","body":"【LeetCode with Python】 7. Reverse Integer题目分析代码【LeetCode with Python】 7. Reverse Integer tagsstart Easy Problems Math tagsstop 题目 原题页面：https://leetcode.com/problems/reverse-integer/ 本文地址：http://leetcode.xnerv.wang/reverse-integer/ 题目类型：Math 难度评价：Easy 类似题目：(E) String to Integer (atoi) Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Update (2014-11-10): Test cases had been added to test the overflow behavior. 分析 “反转”一个数字。主要注意负数的处理。数值计算类面试题有一个经常会被忽略的重要点，就是数值溢出。这里是用Python解题，所以对于超出int范围的输入参数处理还不会有问题。但是题目要求在int溢出的情况下返回0，因此要注意检查输入，并且在反转的过程中时刻检查是否溢出。 此外还要注意Python的一个坑，之前直接用的sys.maxint来表示int最大值，在64位win7上结果正确，但在leetcode网站上跑时就出错了，发现是因为sys.maxint在windows上是32位，而在linux上则是64位，官方文档上说的也是 \"This is at least 2**31-1\"。 代码 class Solution: # @return an integer def reverse(self, x): if x > 0x7fffffff or x = 0: leave = x sign = 1 else: leave = -x sign = -1 result = 0 while 0 != leave: result = result * 10 + leave % 10 sign_result = result * sign if sign_result > 0x7fffffff or sign_result Welcome to my blob Xnerv Surveys "},"string-to-integer-atoi/":{"url":"string-to-integer-atoi/","title":"8. String to Integer (atoi)","keywords":"","body":"【LeetCode with Python】 8. String to Integer (atoi)题目分析代码【LeetCode with Python】 8. String to Integer (atoi) tagsstart Easy Problems Math String tagsstop 题目 原题页面：https://leetcode.com/problems/string-to-integer-atoi/ 本文地址：http://leetcode.xnerv.wang/string-to-integer-atoi/ 题目类型：Easy 难度评价：Math, String 类似题目：(E) Reverse Integer, (H) Valid Number Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 分析 正负号自然不用说，还要注意字符串开头允许任意长度的空格，结尾允许任意长度的非数字字符。 int为32位数据类型，当字符串代表的整数值超出int的表示范围时（大于int最大值，或小于int最小值），要能截断到int的最大值或最小值。但是如何判断当前的值已经大于int最大值或者小于int最小值，此时如果用int存储当前值的话，已经发生溢出而出错。当然，这里是用Python来解题的，整数变量的范围不止32位。但是如果是用C++结题呢？一般两种做法，一个是用更大的数据类型，如long long来存储当前值。还有一种办法，就是类似于下面的代码中的方法，就是直接用当前值的字符串，和int最大值最小值的字符串去进行字符串大小比较。 代码 class Solution: def __init__(self): self.max_int_bits = 32 self.max_int_str = str(pow(2, self.max_int_bits - 1) - 1) self.min_int_str = str(pow(2, self.max_int_bits - 1)) # abs value, without sign self.max_int_len = len(self.max_int_str) self.min_int_len = len(self.min_int_str) # @return an integer def atoi(self, str): len_s = len(str) if 0 == len_s: return 0 index = 0 while index = '0' and ch self.max_int_len or len(val_str) > self.min_int_len: return int(self.max_int_str) if 1 == sign else -int(self.min_int_str) if len(val_str) >= self.max_int_len and val_str > self.max_int_str: return int(self.max_int_str) if 1 == sign else -int(self.min_int_str) value = value * 10 + ord(ch) - ord('0') index += 1 else: break return value * sign Welcome to my blob Xnerv Surveys "},"palindrome-number/":{"url":"palindrome-number/","title":"9. Palindrome Number","keywords":"","body":"【LeetCode with Python】 9. Palindrome Number题目分析代码【LeetCode with Python】 9. Palindrome Number tagsstart Easy Problems Math tagsstop 题目 原题页面：https://leetcode.com/problems/palindrome-number/ 本文地址：http://leetcode.xnerv.wang/palindrome-number/ 题目类型：Math 难度评价：Easy 类似题目：(E) Palindrome Linked List Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 分析 判断一个数值是否是回文。首先负数肯定不是回文，而0~9则是回文。基本的思路是每次对比数值开头的数字和结尾的数字，看是不是相等。结尾的数字可以通过对10取余得到，于是问题的关键就在于怎样取出开头的数字了。 注意不要去尝试将整个数值倒置，这样可能会造成溢出。（不过如果这个数值是回文的话，倒置也不会溢出就是了。但是有没有可能一个数值本来不是回文，倒置后溢出的结果反而等于原数值了？？？） 代码 class Solution: # @return a boolean def isPalindrome(self, x): if x 0: div *= 10 else: break while div > 0: left = int(x / div) right = int(x % 10) if left != right: return False x = x % div x = x / 10 div = int(div / 100) return True Welcome to my blob Xnerv Surveys "},"regular-expression-matching/":{"url":"regular-expression-matching/","title":"10. Regular Expression Matching","keywords":"","body":"【LeetCode with Python】 10. Regular Expression Matching题目分析代码【LeetCode with Python】 10. Regular Expression Matching tagsstart Hard Problems Dynamic Programming Backtracking String tagsstop 题目 原题页面：https://leetcode.com/problems/regular-expression-matching/ 本文地址：http://leetcode.xnerv.wang/regular-expression-matching/ 题目类型：Dynamic Programming, Backtracking, String 难度评价：Hard 类似题目：(H) Wildcard Matching Implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"a\") → true isMatch(\"aa\", \".\") → true isMatch(\"ab\", \".\") → true isMatch(\"aab\", \"cab\") → true 分析 和Wildcard Matching这道题类似，动态规划算法本身已经不是难点，关键在于最好对一些特殊cases做预处理： 模式串p中连续的对可以合并成一个，如aa可以合并为a，而..也可以合并为. 模式串p中实体字符（不带）的个数大于字符串s的长度时，匹配失败 模式串p中没有任何实体字符，而字符串s长度为0时，匹配成功 此外，目前用的解法已经将使用到的DP矩阵减小到了两行，可以继续优化到2*2的小矩阵。 代码 class Solution: class Item: def __init__(self, char, symbol): self.char = char self.symbol = symbol def splitStr(self, str): items = [ ] index = 0 len_str = len(str) while index = len_str or '*' != str[index + 1]: items.append(Solution.Item(str[index], '')) index += 1 else: items.append(Solution.Item(str[index], '*')) index += 2 return items # @param s, an input string # @param p, a pattern string # @return a boolean def isMatch(self, s, p): if '' == s and '' == p: return True p_arr = self.splitStr(p) len_s = len(s) len_p_arr = len(p_arr) last_item = Solution.Item(None, None) p_char_num = 0 new_p_arr = [ ] for i in range(0, len_p_arr): if last_item.char == p_arr[i].char and last_item.symbol == p_arr[i].symbol and '*' == p_arr[i].symbol: pass else: new_p_arr.append(p_arr[i]) last_item = p_arr[i] if '' == p_arr[i].symbol: p_char_num += 1 if p_char_num > len_s: return False if 0 ==p_char_num and 0 == len_s: return True F = [[False for j in range(0, len_p_arr + 1)] for i in range(0, 2)] # 3 cases for True: # last ch matched, and this ch matcheds (right-down) # p comes x*, and last matched (right) # last p.symbol is x*, s comes matched ch x, and last matched (down) for i in range(1, len_s + 1): if 1 == i: F[0][0] = True for j in range(1, len_p_arr + 1): F[0][j] = (F[0][j - 1] and '*' == p_arr[j - 1].symbol) else: for j in range(0, len_p_arr + 1): # cannot be F[0] = F[1] F[0][j] = F[1][j] F[1][0] = False for j in range(1, len_p_arr + 1): if True == F[0][j - 1] and (p_arr[j - 1].char == s[i - 1] or '.' == p_arr[j - 1].char): F[1][j] = True elif True == F[1][j - 1] and '*' == p_arr[j - 1].symbol: F[1][j] = True elif True == F[0][j] and (s[i - 1] == p_arr[j - 1].char or '.' == p_arr[j - 1].char)and '*' == p_arr[j - 1].symbol: F[1][j] = True else: F[1][j] = False return F[1][len_p_arr] Welcome to my blob Xnerv Surveys "},"container-with-most-water/":{"url":"container-with-most-water/","title":"11. Container With Most Water","keywords":"","body":"【LeetCode with Python】 11. Container With Most Water题目分析代码【LeetCode with Python】 11. Container With Most Water tagsstart Medium Problems Array Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/container-with-most-water/ 本文地址：http://leetcode.xnerv.wang/container-with-most-water/ 题目类型：Array, Two Pointers 难度评价：Medium 类似题目：(H) Trapping Rain Water Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. 分析 贪婪法的思想，用两个指针从数组的左边和右边开始，向中间搜索。依据的理由有两点： 1、因为一开始底边长就已经是最大，两个指针向中间移动的时候，底边长只会变短，因此如果此时面积要变大的话，只能是两条高中的最短者比移动前的最短高更高，否则就无需考察，直接continue到下一次的循环。 2、因此，每次选择移动左指针还是右指针，优先选择当前高度最短的那个，以期寻找到更高的边。如果此时选择移动当前高度最高的那个，就有可能跳过了最优解。 代码 class Solution: # @return an integer def maxArea(self, height): len_height = len(height) if 1 == len_height: return 0 max_area = 0 left_index = 0 right_index = len_height - 1 while left_index max_area: max_area = area return max_area Welcome to my blob Xnerv Surveys "},"integer-to-roman/":{"url":"integer-to-roman/","title":"12. Integer to Roman","keywords":"","body":"【LeetCode with Python】 12. Integer to Roman题目分析代码【LeetCode with Python】 12. Integer to Roman tagsstart Medium Problems Math String tagsstop 题目 原题页面：https://leetcode.com/problems/integer-to-roman/ 本文地址：http://leetcode.xnerv.wang/integer-to-roman/ 题目类型：Math, String 难度评价：Medium 类似题目：(E) Roman to Integer, (M) Integer to English Words Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 分析 将一个int转化为对应的罗马数字表示。 罗马数字还是挺复杂的，尤其是在和阿拉伯数字转换之时。建议可以看看维基百科，反正我是看晕了，最后找了前人的这题解法才算明白。 首先，罗马数字是不能表示负数和零的，所以遇到这样的阿拉伯数字时就直接返回空字符串吧。然后基本思路是，按照罗马数字从大到小的优先顺序，每次都从阿拉伯数字num中减去一个够减的罗马数字代表的数值，然后循环直到num为0为止。然后最大的问题来了，那就是罗马数字里像IV（4），XC（90）等这种，貌似还有一些惯例用法，像8是VIII而不是IIX，C的左边只能用X而不能用I等，复杂到了极点。我的建议是：罗马灭亡是有其缘由的，我们就不必在他们的文化上再纠结了。将单个罗马数字和惯例用法按数值从大到小排列，然后按照上面提到的基本思路来求解。 空间复杂度是O(n)。时间复杂度大约是O(n)？ 代码 class Solution: # @return a string def intToRoman(self, num): if num 0: for i in range(0, len): if num >= nums[i]: num -= nums[i] s += chs[i] break return s Welcome to my blob Xnerv Surveys "},"roman-to-integer/":{"url":"roman-to-integer/","title":"13. Roman to Integer","keywords":"","body":"【LeetCode with Python】 13. Roman to Integer题目分析代码【LeetCode with Python】 13. Roman to Integer tagsstart Easy Problems Math String tagsstop 题目 原题页面：https://leetcode.com/problems/roman-to-integer/ 本文地址：http://leetcode.xnerv.wang/roman-to-integer/ 题目类型：Math, String 难度评价：Easy 类似题目：(M) Integer to Roman Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 分析 将一个罗马数值字符串转化为相应的int。 此题跟Integer to Roman有异曲同工之蛋疼，对于不熟悉罗马数字的童鞋就是一个噩梦。整体来说，罗马数字中的字符代表的数值大小，一般是从左至右非严格递减的（也就是说可能相邻的两个字符相等），然后不停地累加就行了。但如果发生相邻的两个元素，左边的字符比右边的字符代表的数值小，就需要减去左右这个字符代表的数值。如IV就是5-4=1，所以CIV就是100-1+5=104。 空间复杂度O(N)。时间复杂度O(N)。 注意IV等这类特殊情况。 代码 class Solution: # @return an integer def romanToInt(self, s): digits = { \"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000 } len_s = len(s) num = 0 for i in range(0, len_s - 1): cur = digits[s[i]] next = digits[s[i + 1]] if cur >= next: num += cur else: num -= cur num += digits[s[len_s - 1]] return num Welcome to my blob Xnerv Surveys "},"longest-common-prefix/":{"url":"longest-common-prefix/","title":"14. Longest Common Prefix","keywords":"","body":"【LeetCode with Python】 14. Longest Common Prefix题目分析代码【LeetCode with Python】 14. Longest Common Prefix tagsstart Easy Problems String tagsstop 题目 原题页面：https://leetcode.com/problems/longest-common-prefix/ 本文地址：http://leetcode.xnerv.wang/longest-common-prefix/ 题目类型：String 难度评价：Easy Write a function to find the longest common prefix string amongst an array of strings. 分析 很简单的题目，找一堆字符串的最长公共前缀。先找str1和str2的最长公共前缀例如str1_2，再找str1_2和str3的最长公共前缀str1_2_3…… 代码 class Solution: def findPrefix(self, str1, str2): min_len = min(len(str1), len(str2)) for i in range(0, min_len): if str1[i] != str2[i]: return str1[0:i] return str1[0:min_len] # @return a string def longestCommonPrefix(self, strs): if None == strs: return \"\" n = len(strs) if 0 == n: return \"\" elif 1 == n: return strs[0] prefix = strs[0] for str in strs[1:]: prefix = self.findPrefix(prefix, str) if \"\" == prefix: break return prefix Welcome to my blob Xnerv Surveys "},"letter-combinations-of-a-phone-number/":{"url":"letter-combinations-of-a-phone-number/","title":"17. Letter Combinations of a Phone Number","keywords":"","body":"【LeetCode with Python】 17. Letter Combinations of a Phone Number题目分析代码【LeetCode with Python】 17. Letter Combinations of a Phone Number tagsstart Medium Problems Backtracking String tagsstop 题目 原题页面：https://leetcode.com/problems/letter-combinations-of-a-phone-number/ 本文地址：http://leetcode.xnerv.wang/letter-combinations-of-a-phone-number/ 题目类型：Backtracking, String 难度评价：Medium 类似题目：(M) Generate Parentheses, (M) Combination Sum Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Input: Digit string \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 分析 原题标注类型递归回溯，可能是希望用递归回溯来解决这个问题。但其实这是个尾递归，所以可以直接用循环代替。 代码 class Solution: # @return a list of strings, [s1, s2] def letterCombinations(self, digits): map = { \"0\": (), \"1\": (), \"2\": (\"a\", \"b\", \"c\"), \"3\": (\"d\", \"e\", \"f\"), \"4\": (\"g\", \"h\", \"i\"), \"5\": (\"j\", \"k\", \"l\"), \"6\": (\"m\", \"n\", \"o\"), \"7\": (\"p\", \"q\", \"r\", \"s\"), \"8\": (\"t\", \"u\", \"v\"), \"9\": (\"w\", \"x\", \"y\", \"z\") } result1 = [ \"\" ] result2 = [ ] for ch in digits: list = map[ch] if 0 == len(list): continue for str in result1: for suffix in list: result2.append(str + suffix) result1 = result2 result2 = [ ] return result1 Welcome to my blob Xnerv Surveys "},"remove-nth-node-from-end-of-list/":{"url":"remove-nth-node-from-end-of-list/","title":"19. Remove Nth Node From End of List","keywords":"","body":"【LeetCode with Python】 19. Remove Nth Node From End of List题目分析代码【LeetCode with Python】 19. Remove Nth Node From End of List tagsstart Easy Problems Linked List Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/remove-nth-node-from-end-of-list/ 本文地址：http://leetcode.xnerv.wang/remove-nth-node-from-end-of-list/ 题目类型：Linked List, Two Pointers 难度评价：Easy Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Try to do this in one pass. 分析 常见的快慢指针题目。快指针领先慢指针n步，这样当快指针到达尾部时，慢指针正好指向需要删除的节点的父结点。 注意由于要删除的结点可能刚好是head节点，这种情况与其特殊处理，不如加一个“伪head”，这也是类似的链表类题目的通用做法。 代码 class Solution: # @return a ListNode def removeNthFromEnd(self, head, n): if None == head: return head if None == head.next: return None new_head = ListNode(-1) new_head.next = head fast = new_head for i in range(0, n): if None != fast.next: fast = fast.next else: return head slow = new_head while None != fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return new_head.next Welcome to my blob Xnerv Surveys "},"valid-parentheses/":{"url":"valid-parentheses/","title":"20. Valid Parentheses","keywords":"","body":"【LeetCode with Python】 20. Valid Parentheses题目分析代码【LeetCode with Python】 20. Valid Parentheses tagsstart Easy Problems Stack String tagsstop 题目 原题页面：https://leetcode.com/problems/valid-parentheses/ 本文地址：http://leetcode.xnerv.wang/valid-parentheses/ 题目类型：Stack, String 难度评价：Easy 类似题目：(M) Generate Parentheses, (H) Longest Valid Parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not. 分析 大家肯定在大学时都做过这道题目吧，不过可能相对简单一点，只涉及小括号的配对，这里需要考虑三种括号，不过还是一样的简单。 用栈来记录遇到的左括号，每次遇到右括号，就从栈中弹出一个左括号，看是不是与该右括号是匹配的。 代码 class Solution: def isMatch(self, l ,r): return (\"(\" == l and \")\" == r) or (\"[\" == l and \"]\" == r) or (\"{\" == l and \"}\" == r) # @return a boolean def isValid(self, s): len_s = len(s) if 0 == len(s): return True arr = [ ] for ch in s: len_arr = len(arr) if 0 == len_arr or not self.isMatch(arr[len_arr - 1], ch): arr.append(ch) else: arr.pop() return 0 == len(arr) Welcome to my blob Xnerv Surveys "},"merge-two-sorted-lists/":{"url":"merge-two-sorted-lists/","title":"21. Merge Two Sorted Lists","keywords":"","body":"【LeetCode with Python】 21. Merge Two Sorted Lists题目分析代码【LeetCode with Python】 21. Merge Two Sorted Lists tagsstart Easy Problems Linked List tagsstop 题目 原题页面：https://leetcode.com/problems/merge-two-sorted-lists/ 本文地址：http://leetcode.xnerv.wang/merge-two-sorted-lists/ 题目类型：Linked List 难度评价：Easy 类似题目：(H) Merge k Sorted Lists, (E) Merge Sorted Array, (M) Sort List, (M) Shortest Word Distance II Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 分析 合并两个有序链表，大学期间常见的数据结构练习题。用两个指针分别指向两个链表头，然后每次都将两者中最小的那个节点加入到到合并后的链表尾部。注意当其中一个链表的节点全部处理完时，别忘了将另一个链表剩余的节点依次全部加入到合并后的链表尾部。 代码 class Solution: # @param two ListNodes # @return a ListNode def mergeTwoLists(self, l1, l2): if None == l1 and None == l2: return None elif None == l1: return l2 elif None == l2: return l1 new_list = ListNode(0) cur = new_list node1 = l1 node2 = l2 while None != node1 and None != node2: if node1.val Welcome to my blob Xnerv Surveys "},"generate-parentheses/":{"url":"generate-parentheses/","title":"22. Generate Parentheses","keywords":"","body":"【LeetCode with Python】 22. Generate Parentheses题目分析代码【LeetCode with Python】 22. Generate Parentheses tagsstart Medium Problems Backtracking String tagsstop 题目 原题页面：https://leetcode.com/problems/generate-parentheses/ 本文地址：http://leetcode.xnerv.wang/generate-parentheses/ 题目类型：Backtracking, String 难度评价：Medium Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" 分析 常见的递归回溯题目，要求左右括号匹配出现。只要符合一个规则即可认为是匹配：从左往右遍历时，左括号的数量>=右括号的数量。因此，每一层递归时，有两种分支选择：添加左括号，或者添加右括号。某一个分支能否继续，取决于是否符合上述规则。而判断分支的结束，就在于n个左括号和n个右括号都已经出现完。 代码中的left_count是记录当前层次递归时已经出现过的左括号数，left_remain是记录可供“消耗”的左括号数，即当前左括号数减去右括号数。Python的两个列表相加，表示将两个子列表合并成一个列表，如[1, 2] + [3] = [1, 2, 3]。 代码 class Solution: def doGenerateParenthesis(self, n, left_count, left_remain, prefix): # only one out-point: the string has been finished. if n == left_count and 0 == left_remain: return [ prefix ] left_list = [ ] right_list = [ ] if left_count 0: right_list = self.doGenerateParenthesis(n, left_count, left_remain - 1, prefix + \")\") return left_list + right_list # @param an integer # @return a list of string def generateParenthesis(self, n): if 0 == n: return [ ] else: list = self.doGenerateParenthesis(n, 0, 0, \"\") return list Welcome to my blob Xnerv Surveys "},"swap-nodes-in-pairs/":{"url":"swap-nodes-in-pairs/","title":"24. Swap Nodes in Pairs","keywords":"","body":"【LeetCode with Python】 24. Swap Nodes in Pairs题目分析代码【LeetCode with Python】 24. Swap Nodes in Pairs tagsstart Medium Problems Linked List tagsstop 题目 原题页面：https://leetcode.com/problems/swap-nodes-in-pairs/ 本文地址：http://leetcode.xnerv.wang/swap-nodes-in-pairs/ 题目类型：Medium 难度评价：Linked List 类似题目：(H) Reverse Nodes in k-Group Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1->2->3->4, you should return the list as 2->1->4->3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 分析 交换单链表中每一对相邻的奇偶数下标的元素，注意防止链表长度可能是奇数，即不要忘记检查second_node是否为None。 代码 class Solution: # @param a ListNode # @return a ListNode def swapPairs(self, head): if None == head: return head new_head = ListNode(0) new_head.next = head last_node = new_head while True: first_node = last_node.next if None == first_node: break second_node = first_node.next if None == second_node: break last_node.next, first_node.next, second_node.next, last_node = second_node, second_node.next, first_node, first_node return new_head.next Welcome to my blob Xnerv Surveys "},"remove-duplicates-from-sorted-array/":{"url":"remove-duplicates-from-sorted-array/","title":"26. Remove Duplicates from Sorted Array","keywords":"","body":"【LeetCode with Python】 26. Remove Duplicates from Sorted Array题目分析代码【LeetCode with Python】 26. Remove Duplicates from Sorted Array tagsstart Easy Problems Array Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/remove-duplicates-from-sorted-array/ 本文地址：http://leetcode.xnerv.wang/remove-duplicates-from-sorted-array/ 题目类型：Array, Two Pointers 难度评价：Easy Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length. 分析 有序数组的去重。关键在于下标操作，不要每次删除元素都整体移动后面的元素。 代码 class Solution: # @param a list of integers @return an integer def removeDuplicates(self, A): if None == A: return 0 len_A = len(A) if len_A Welcome to my blob Xnerv Surveys "},"remove-element/":{"url":"remove-element/","title":"27. Remove Element","keywords":"","body":"【LeetCode with Python】 27. Remove Element题目分析代码【LeetCode with Python】 27. Remove Element tagsstart Easy Problems Array Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/remove-element/ 本文地址：http://leetcode.xnerv.wang/remove-element/ 题目类型：Array, Two Pointers 难度评价：Easy 类似题目：(E) Remove Linked List Elements, (E) Move Zeroes Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length. 分析 题目已经暗示可以将需要删除的元素移至数组末尾，因此用两个下标m和n，m用来从左至右遍历数组寻找该元素，n从右至左记录可以用来交换的尾部位置。 代码 class Solution: # @param A a list of integers # @param elem an integer, value need to be removed # @return an integer def removeElement(self, A, elem): if None == A: return A len_A = len(A) m = 0 n = len_A - 1 while m Welcome to my blob Xnerv Surveys "},"divide-two-integers/":{"url":"divide-two-integers/","title":"29. Divide Two Integers","keywords":"","body":"【LeetCode with Python】 29. Divide Two Integers题目分析代码【LeetCode with Python】 29. Divide Two Integers tagsstart Medium Problems Math Binary Search tagsstop 题目 原题页面：https://leetcode.com/problems/divide-two-integers/ 本文地址：http://leetcode.xnerv.wang/divide-two-integers/ 题目类型：Math, Binary Search 难度评价：Medium Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. 分析 代码 class Solution: # @return an integer def divide(self, dividend, divisor): if 0 == divisor or 0 == dividend: return 0 elif 1 == divisor or -1 == divisor: return dividend * divisor positive = 1 if (dividend >0 and divisor 0): positive = -1 dividend = dividend if dividend > 0 else -dividend divisor = divisor if divisor > 0 else -divisor result = 0 dividend_now = dividend while dividend_now >= divisor: total = divisor sub_result = 1 while True: total = total dividend_now: total = total >> 1 sub_result = sub_result >> 1 break elif total == dividend_now: break result += sub_result dividend_now -= total return result * positive Welcome to my blob Xnerv Surveys "},"search-in-rotated-sorted-array/":{"url":"search-in-rotated-sorted-array/","title":"33. Search in Rotated Sorted Array","keywords":"","body":"【LeetCode with Python】 33. Search in Rotated Sorted Array题目分析代码【LeetCode with Python】 33. Search in Rotated Sorted Array tagsstart Hard Problems Array Binary Search tagsstop 题目 原题页面：https://oj.leetcode.com/problems/search-in-rotated-sorted-array/ 本文地址：http://leetcode.xnerv.wang/search-in-rotated-sorted-array/ 题目类型：Array, Binary Search 难度评价：Hard 类似题目：(M) Search in Rotated Sorted Array II, (M) Find Minimum in Rotated Sorted Array Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 分析 二分查找的一个变种。整个数组由两个有序的子序列构成，且左子序列中的每个元素都>,右子序列中的每个元素。 如果每次A[left] 题目中说明了数组中没有重复元素，因为有重复元素的情况下，上述算法可能会有问题。例如，序列是[4 5 6 7 0 3 4]，寻找的元素是3，则第一次时因为mid是7，则会进入左侧段中查找，则显然是找不到3的。 代码 class Solution: def doSearch(self, A, left, right, target): len_A = right - left + 1 if 0 == len_A: return -1 elif 1 == len_A: ### return left if target == A[left] else -1 if A[left] target: right = mid - 1 else: return mid else: mid = (left + right) / 2 left_result = self.doSearch(A, left, mid, target) if -1 != left_result: return left_result else: right_result = self.doSearch(A, mid + 1, right, target) if -1 != right_result: return right_result return -1 # @param A, a list of integers # @param target, an integer to be searched # @return an integer def search(self, A, target): len_A = len(A) return self.doSearch(A, 0, len(A) - 1, target) Welcome to my blob Xnerv Surveys "},"search-insert-position/":{"url":"search-insert-position/","title":"35. Search Insert Position","keywords":"","body":"【LeetCode with Python】 35. Search Insert Position题目分析代码【LeetCode with Python】 35. Search Insert Position tagsstart Medium Problems Array Binary tagsstop 题目 原题页面：https://oj.leetcode.com/problems/search-insert-position/ 本文地址：http://leetcode.xnerv.wang/search-insert-position/ 题目类型：Array, Binary Search 难度评价：Medium 类似题目：(E) First Bad Version Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. [1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 分析 二分查找的一个变种。如果找到了target，就返回下标（正常的二分查找逻辑），否则就返回插入的位置。二分查找容易搞晕的是到底是返回left还是right，注意到left最终一定停在target上，或停在target的“位置”的右边，所以显然找不到target时，应该返回left的下标作为插入位置。 代码 class Solution: # @param A, a list of integers # @param target, an integer to be inserted # @return integer def searchInsert(self, A, target): if None == A: return 0 len_A = len(A) if target > A[len_A - 1]: return len_A if target target: right = mid - 1 else: return mid return left Welcome to my blob Xnerv Surveys "},"count-and-say/":{"url":"count-and-say/","title":"38. Count and Say","keywords":"","body":"【LeetCode with Python】 38. Count and Say题目分析代码【LeetCode with Python】 38. Count and Say tagsstart Easy Problems String tagsstop 题目 原题页面：https://leetcode.com/problems/count-and-say/ 本文地址：http://leetcode.xnerv.wang/count-and-say/ 题目类型：String 难度评价：Easy 类似题目：(M) Encode and Decode Strings The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, ... 1 is read off as \"one 1\" or 11. 11 is read off as \"two 1s\" or 21. 21 is read off as \"one 2, then one 1\" or 1211. Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. 分析 主要是计数的逻辑。每一轮，遇到一个不同的字符时，就结束到该轮的计数。但是需要注意的是最后一轮的计数，因为遇到的是字符串src的结尾，所以需要强制结束这一轮的计数，就类似于编译原理词法分析最后的那个$符号的作用。 代码 class Solution: def doCountAndSay(self, src): char = src[0] num = 0 result = \"\" for c in src: if char == c: num += 1 else: result += (str(num) + char) char = c num = 1 result += (str(num) + char) return result # @return a string def countAndSay(self, n): if 0 == n: return \"\" elif 1 == n: return \"1\" result = \"1\" # str is a keyword for i in range(1, n): result = self.doCountAndSay(result) return result Welcome to my blob Xnerv Surveys "},"combination-sum/":{"url":"combination-sum/","title":"39. Combination Sum","keywords":"","body":"【LeetCode with Python】 39. Combination Sum题目分析代码【LeetCode with Python】 39. Combination Sum tagsstart Medium Problems Array Backtracking tagsstop 题目 原题页面：https://leetcode.com/problems/combination-sum/ 本文地址：http://leetcode.xnerv.wang/combination-sum/ 题目类型：Array, Backtracking 难度评价：Medium 类似题目：(M) Letter Combinations of a Phone Number, (M) Combination Sum II, (M) Combinations, (M) Combination Sum III, (M) Factor Combinations Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak). The solution set must not contain duplicate combinations. For example, given candidate set 2,3,6,7 and target 7, A solution set is: [7] [2, 2, 3] 分析 比较经典的递归回溯和组合问题。每个元素可以被使用多次，注意参数传入的set可能不是有序的，为确保万一先sort吧。这道题有两个值得思考的地方： 为什么不能用动态规划来解决这个问题？什么样的题可以用动态规划，动态规划究竟是什么，这个定义上的问题一直困扰着本人。但是至少可以确定一点，动态规划是用来解决最优化问题的，而不是组合问题。例如如果这道题改为，从集合中挑选出一个子集合，使其最接近于给出的target值，但是又不能超过target值，那这道题就是动态规划中典型的背包问题了。（好像不太对，像Interleaving String这个DP问题就是一个排列问题，而不是一个优化问题。DP问题可能得是一个可迭代分解的问题。） 无限递归问题。注意代码中的used变量，因为set中的值可以被使用多次。。。 另外注意题目说的是“a set of candidate numbers”，既然是set，说明numbers中是没有重复元素的。 （本题感觉理解得还不是很清楚） 代码 class Solution: def __init__(self): self.nums = None self.len_nums = 0 self.total = 0 self.combinations = [ ] def doCombinationSum(self, prefix, prefix_total, start, last, used): if start >= self.len_nums: return num = self.nums[start] result = True # 只有当第一次考察该元素，或虽然不是第一次考察该元素，但是该元素上一轮已经被采用，才能继续下去 if num != last or used: ### if prefix_total + num == self.total: new_prefix = prefix[:] new_prefix.append(num) self.combinations.append(new_prefix) return elif prefix_total + num Welcome to my blob Xnerv Surveys "},"combination-sum-ii/":{"url":"combination-sum-ii/","title":"40. Combination Sum II","keywords":"","body":"【LeetCode with Python】 40. Combination Sum II题目分析代码【LeetCode with Python】 40. Combination Sum II tagsstart Medium Problems Array Backtracking tagsstop 题目 原题页面：https://leetcode.com/problems/combination-sum-ii/ 本文地址：http://leetcode.xnerv.wang/combination-sum-ii/ 题目类型：Array, Backtracking 难度评价：Medium 类似题目：(M) Combination Sum Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak). The solution set must not contain duplicate combinations. For example, given candidate set 10,1,2,7,6,1,5 and target 8, A solution set is: [1, 7] [1, 2, 5] [2, 6] [1, 1, 6] 分析 代码 # Definition for singly-linked list with a random pointer. class Solution: def __init__(self): self.nums = None self.len_nums = 0 self.total = 0 self.combinations = [ ] def doCombinationSum(self, prefix, prefix_total, start, last, used): if start >= self.len_nums: return num = self.nums[start] result = True if num != last or used: ### if prefix_total + num == self.total: new_prefix = prefix[:] new_prefix.append(num) self.combinations.append(new_prefix) return elif prefix_total + num Welcome to my blob Xnerv Surveys "},"trapping-rain-water/":{"url":"trapping-rain-water/","title":"42. Trapping Rain Water","keywords":"","body":"【LeetCode with Python】 42. Trapping Rain Water题目分析代码【LeetCode with Python】 42. Trapping Rain Water tagsstart Hard Problems Array Stack Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/trapping-rain-water/ 本文地址：http://leetcode.xnerv.wang/trapping-rain-water/ 题目类型：Array, Stack, Two Pointers 难度评价：Hard 类似题目：(M) Container With Most Water, (M) Product of Array Except Self Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image! 分析 将一个数列看成是一堆高低不一的蓄水墙，数值即这面墙的高度，求总的蓄水最大量。其实题目中的图就已经一目了然了，无需过多文字说明。 针对某一个x点，决定其蓄水量应该是该点左右两边分别出现过的最高的墙中的最小者决定的。例如，针对A=[0,1,0,2,1,0,1,3,2,1,2,1]这个例子，A[4]=1这一点，其左边出现过的最高墙是A[3]=2，其右边出现过的最高墙是A[7]=3，因此两者中的最小者就就是A[3]=2，因此A[4]的蓄水高度就是A[3]-A[4]=1，乘以底边1，即A[4]蓄水量为1。 针对每一个点去单独寻找这个最小值显然是不合理的，这样时间复杂度就是O(n*n)了。申请一个与原数组A等长的数组max_heights用来记录每个点的最大蓄水量，首先从左至右遍历一次A，记录当前遇到过的最大值，依次填入到max_heights中。然后再从右至左遍历一次A，也记录当前遇到过的最大值，与max_heights中对应位置的值进行比较，如果比max_heights中对应的值小，则替换掉max_heights中的值。通过这种方法，就能用2次时间复杂度为O(n)的遍历找出每个点的蓄水量，然后遍历max_heights，如果比A中对应的数值大的话，就累加其差值，最后得到的就是蓄水总量。也就是说，如果A中数值对max_heights中对应数值大，说明这个点无法蓄水。 空间复杂度为O(n)，时间复杂度为O(n)。 代码 class Solution: # @param A, a list of integers # @return an integer def trap(self, A): len_A = len(A) if 1 == len_A: return 0 max_heights = [0] * len_A left_max = 0 for i in range(0, len_A): if A[i] > left_max: left_max = A[i] max_heights[i] = left_max right_max = 0 for i in range(len_A - 1, -1, -1): if A[i] > right_max: right_max = A[i] if right_max A[i]: result += (max_heights[i] - A[i]) return result Welcome to my blob Xnerv Surveys "},"wildcard-matching/":{"url":"wildcard-matching/","title":"44. Wildcard Matching","keywords":"","body":"【LeetCode with Python】 44. Wildcard Matching题目分析代码【LeetCode with Python】 44. Wildcard Matching tagsstart Hard Problems Dynamic Programming Backtracking Greedy String tagsstop 题目 原题页面：https://leetcode.com/problems/wildcard-matching/ 本文地址：http://leetcode.xnerv.wang/wildcard-matching/ 题目类型：Dynamic Programming, Backtracking, Greedy, String 难度评价：Hard 类似题目： (H) Regular Expression Matching Implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"\") → true isMatch(\"aa\", \"a\") → true isMatch(\"ab\", \"?\") → true isMatch(\"aab\", \"cab\") → false 分析 这道动态规划的题，其特殊test case造成的麻烦已经远远超过动态规划算法本身的复杂带来的麻烦了。之前在优化动态规划算法时，一直注重的是空间的优化，却没有考虑到有些cases是可以提前检测或进行预处理，从而降低运行时间的。如果不这样做，将一直卡在一些特别长的变态cases上Time Limit Exceeded。 模式串p中连续的可以预处理合并为一个 模式串中问号和字符的总数大于字符串s的长度时，匹配失败 模式串中字符个数为0时，如果模式串中问号总数等于s长度，则匹配成功，否则匹配失败 代码 class Solution: # @param s, an input string # @param p, a pattern string # @return a boolean def isMatch(self, s, p): if (None == s or '' == s) and (None == p or '' == p): return True len_s = len(s) len_p = len(p) new_p = '' last_ch = None p_solid_char_num = 0 for i in range(0, len_p): if '*' != last_ch or '*' != p[i]: new_p += p[i] last_ch = p[i] if '*' != p[i]: p_solid_char_num += 1 if p_solid_char_num > len_s: return False isAllStars = True if (None == s or '' == s) and 0 == p_solid_char_num: return True p = new_p len_p = len(new_p) F = [[False for j in range(0, len_p + 1)] for i in range(0, 2)] # 3 cases for True: # last ch matched, and this ch matcheds (right-down) # p comes *, and last matched (right) # last p.ch is *, s comes any ch, and last matched (down) for i in range(1, len_s + 1): if 1 == i: F[0][0] = True for j in range(1, len_p + 1): F[0][j] = (F[0][j - 1] and '*' == p[j - 1]) else: for j in range(0, len_p + 1): # cannot be F[0] = F[1] F[0][j] = F[1][j] F[1][0] = False for j in range(1, len_p + 1): if True == F[0][j - 1] and (p[j - 1] == s[i - 1] or '?' == p[j - 1] or '*' == p[j - 1]): F[1][j] = True elif (True == F[1][j - 1] or True == F[0][j]) and '*' == p[j - 1]: F[1][j] = True else: F[1][j] = False return F[1][len_p] Welcome to my blob Xnerv Surveys "},"permutations/":{"url":"permutations/","title":"46. Permutations","keywords":"","body":"【LeetCode with Python】 46. Permutations题目分析代码【LeetCode with Python】 46. Permutations tagsstart Medium Problems Backtracking tagsstop 题目 原题页面：https://leetcode.com/problems/permutations/ 本文地址：http://leetcode.xnerv.wang/permutations/ 题目类型：Backtracking 难度评价：Medium 类似题目：(M) Next Permutation, (M) Permutations II, (M) Permutation Sequence, (M) Combinations Given a collection of numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1]. 分析 一道递归回溯的题目，所以跟大多数递归回溯题目类似的解法。只有一点值得注意一下，由于需要从一个集合中挑选出元素，然后下一次递归从剩余的元素中继续挑选，所以必须能够记忆和区分出当前已经选出了哪些元素。这里的做法是每次把选择的元素与当前列表中第一个元素交换，然后将除第一个元素外的子列表传递给下一次递归作为其需要处理的当前列表。 另外，a collection of numbers也许是暗示了集合中不会有重复元素？至少对比(M) Permutations II看来，本题的原意应该是没有重复元素的。 代码 class Solution: def doPermute(self, num_list): if 1 == len(num_list): return [ num_list ] res_list = [ ] for i in range(0, len(num_list)): num_list[0], num_list[i] = num_list[i], num_list[0] sub_res_list = self.doPermute(num_list[1:]) list_head = [ num_list[0] ] new_list = [ list_head + list for list in sub_res_list] res_list.extend(new_list) return res_list # @param num, a list of integer # @return a list of lists of integers def permute(self, num): return self.doPermute(num) Welcome to my blob Xnerv Surveys "},"permutations-ii/":{"url":"permutations-ii/","title":"47. Permutations II","keywords":"","body":"【LeetCode with Python】 47. Permutations II题目分析代码【LeetCode with Python】 47. Permutations II tagsstart Medium Problems Backtracking tagsstop 题目 原题页面：https://leetcode.com/problems/permutations-ii/ 本文地址：http://leetcode.xnerv.wang/permutations-ii/ 题目类型：Backtracking 难度评价：Medium 类似题目：(M) Next Permutation, (M) Permutations, (M) Palindrome Permutation II Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example, [1,1,2] have the following unique permutations: [1,1,2], [1,2,1], and [2,1,1]. 分析 与Permutations在处理上的唯一区别是，对于重复元素，不去尝试调换，而是直接skip，避免出现重复的排列。 代码 class Solution: def doPermuteUnique(self, num_list): if 1 == len(num_list): return [ num_list ] res_list = [ ] for i in range(0, len(num_list)): if i > 0 and num_list[0] == num_list[i]: continue num_list[0], num_list[i] = num_list[i], num_list[0] sub_res_list = self.doPermuteUnique(num_list[1:]) list_head = [ num_list[0] ] new_list = [ list_head + list for list in sub_res_list] res_list.extend(new_list) return res_list # @param num, a list of integer # @return a list of lists of integers def permuteUnique(self, num): num.sort() return self.doPermuteUnique(num) Welcome to my blob Xnerv Surveys "},"rotate-image/":{"url":"rotate-image/","title":"48. Rotate Image","keywords":"","body":"【LeetCode with Python】 48. Rotate Image题目分析代码【LeetCode with Python】 48. Rotate Image tagsstart Medium Problems Array tagsstop 题目 原题页面：https://leetcode.com/problems/rotate-image/ 本文地址：http://leetcode.xnerv.wang/rotate-image/ 题目类型：Array 难度评价：Medium You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 分析 顺时针90度转动一个二维矩阵，要求in-place的算法，也就不是不能另外开一个新的矩阵然后把原矩阵上的元素一个个对应复制过来，而要在原矩阵上进行操作。 目前能想到的有两种方法。 第一种比较直观，首先将原矩阵按照水平轴上下翻转，然后按照左上到右下的对角线再反转，则等价于90度顺时针转动。这个方法的缺点是要反转两次，优点是直观，不容易出错。 第二种方法每个元素只需要调整一次，但是转化公式会比较复杂。对于矩阵matrix[n][n]中的某一点matrix[x][y]（0 本文采用第二种方法，空间复杂度O(1)，时间复杂度O(n*n)。 代码 class Solution: # @param matrix, a list of lists of integers # @return nothing (void), do not return anything, modify matrix in-place instead. def rotate(self, matrix): n = len(matrix) if 1 == n: return round = int(n / 2) for x in range(0, round): for y in range(x, n - x - 1): matrix[n - y - 1][x], matrix[n - x - 1][n - y - 1], matrix[y][n - x - 1], matrix[x][y] = matrix[n - x - 1][n - y - 1], matrix[y][n - x - 1], matrix[x][y], matrix[n - y - 1][x] Welcome to my blob Xnerv Surveys "},"pow-x-n/":{"url":"pow-x-n/","title":"50. Pow(x, n)","keywords":"","body":"【LeetCode with Python】 50. Pow(x, n)题目分析代码【LeetCode with Python】 50. Pow(x, n) tagsstart Medium Problems Math Binary Search tagsstop 题目 原题页面：https://leetcode.com/problems/powx-n/ 本文地址：http://leetcode.xnerv.wang/powx-n/ 题目类型：Math, Binary Search 难度评价：Medium 类似题目：(M) Sqrt(x) Implement pow(x, n). 分析 用n个x相乘显然不是应该出现在leetcode上的算法。这里是利用二分的算法，通过递归来加速计算。 例如，pow(x, 5) == (x pow(x, 4)) == (x pow(pow(x, 2), 2))。 代码 class Solution: # @param x, a float # @param n, a integer # @return a float def pow(self, x, n): if 0 == n: return 1 elif n > 1) if 0 == n % 2: return half * half else: return x * half * half Welcome to my blob Xnerv Surveys "},"n-queens/":{"url":"n-queens/","title":"51. N-Queens","keywords":"","body":"【LeetCode with Python】 51. N-Queens题目分析代码【LeetCode with Python】 51. N-Queens tagsstart Hard Problems Backtracking tagsstop 题目 原题页面：https://oj.leetcode.com/problems/n-queens/ 本文地址：http://leetcode.xnerv.wang/n-queens/ 题目类型：Backtracking 难度评价：Hard 类似题目：(H) N-Queens II The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. For example, There exist two distinct solutions to the 4-queens puzzle: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] 分析 下标计算处理，控制好循环条件，下标不要越界即可。 代码 class Solution: def __init__(self): self.paths = [ ] def dpSolveNQueens(self, n, prefix, level): for i in range(0, n): point = (i, level) is_valid = True for m in range(0, len(prefix)): if i == prefix[m]: is_valid = False break if level - m == i - prefix[m] or level - m == prefix[m] - i: is_valid = False break if is_valid: new_prefix = prefix[:] new_prefix.append(i) if n - 1 != level: self.dpSolveNQueens(n, new_prefix, level + 1) else: self.paths.append(new_prefix) # @return a list of lists of string def solveNQueens(self, n): self.dpSolveNQueens(n, [ ], 0) lists = [ ] for path in self.paths: list = [ ] for num in path: str = \".\" * num + \"Q\" + \".\" * (n - num - 1) list.append(str) lists.append(list) return lists Welcome to my blob Xnerv Surveys "},"n-queens-ii/":{"url":"n-queens-ii/","title":"52. N-Queens II","keywords":"","body":"【LeetCode with Python】 52. N-Queens II题目分析代码【LeetCode with Python】 52. N-Queens II tagsstart Hard Problems Backtracking tagsstop 题目 原题页面：https://oj.leetcode.com/problems/n-queens-ii/ 本文地址：http://leetcode.xnerv.wang/n-queens-ii/ 题目类型：Backtracking 难度评价：Hard 类似题目：(H) N-Queens Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. 分析 代码 class Solution: def __init__(self): self.paths_count = 0 def dpTotalNQueens(self, n, prefix, level): for i in range(0, n): point = (i, level) is_valid = True for m in range(0, len(prefix)): if i == prefix[m]: is_valid = False break if level - m == i - prefix[m] or level - m == prefix[m] - i: is_valid = False break if is_valid: new_prefix = prefix[:] new_prefix.append(i) if n - 1 != level: self.dpTotalNQueens(n, new_prefix, level + 1) else: self.paths_count += 1 # @return an integer def totalNQueens(self, n): self.dpTotalNQueens(n, [ ], 0) return self.paths_count Welcome to my blob Xnerv Surveys "},"maximum-subarray/":{"url":"maximum-subarray/","title":"53. Maximum Subarray","keywords":"","body":"【LeetCode with Python】 53. Maximum Subarray题目分析代码【LeetCode with Python】 53. Maximum Subarray tagsstart Medium Problems Divide and Conquer Array Dynamic Programming tagsstop 题目 原题页面：https://leetcode.com/problems/maximum-subarray/ 本文地址：http://leetcode.xnerv.wang/maximum-subarray/ 题目类型：Divide and Conquer, Array, Dynamic Programming 难度评价：Medium 类似题目：(M) Best Time to Buy and Sell Stock, (M) Maximum Product Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. More practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 分析 找最大和连续子数组，也是经典题目之一。和Gas Station有点类似的地方是，如果当前的子序列加入第k个元素后，sum小于0（首先说明k本身小于0），则这个子序列的sum对后续的k+1是无益的。而且即使从这个子序列中移除掉部分最左边的元素，也是没有用的，因为最左边的元素的总和一定是大于0的，移除掉会更差。所以此时不如从第k+1个元素从0开始重新sum。 可以想象一副不规则的波形图，sum就是从x轴的某一点开始的面积图。x轴上方的是有效面积，x轴下方的负数面积。 代码 class Solution: # @param A, a list of integers # @return an integer def maxSubArray(self, A): len_A = len(A) if 1 == len_A: return A[0] max = None sum = 0 for n in range(0, len_A): sum += A[n] if None == max or sum > max: max = sum if sum Welcome to my blob Xnerv Surveys "},"spiral-matrix/":{"url":"spiral-matrix/","title":"54. Spiral Matrix","keywords":"","body":"【LeetCode with Python】 54. Spiral Matrix题目分析代码【LeetCode with Python】 54. Spiral Matrix tagsstart Medium Problems Array tagsstop 题目 原题页面：https://oj.leetcode.com/problems/spiral-matrix/ 本文地址：http://leetcode.xnerv.wang/spiral-matrix/ 题目类型：Array 难度评价：Medium 类似题目：(M) Spiral Matrix II Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example, Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] You should return [1,2,3,6,9,8,7,4,5]. 分析 还是一道下标计算的题目，用两重嵌套for循环，以螺旋状的方式遍历二维数组。 代码 class Solution: # @param matrix, a list of lists of integers # @return a list of integers def spiralOrder(self, matrix): m = len(matrix) if 0 == m: return [ ] n = len(matrix[0]) if 0 == n: return [ ] arr = [ ] round = (min(m, n) + 1) / 2 for x in range(0, round): for y in range(x, n - x): arr.append(matrix[x][y]) for y in range(x + 1, m - x - 1): arr.append(matrix[y][n - x - 1]) if m - 2 * x > 1: ### for y in range(n - x - 1, x - 1, -1): arr.append(matrix[m - x - 1][y]) if n - 2 * x > 1: ### for y in range(m - x - 2, x, -1): ### arr.append(matrix[y][x]) return arr Welcome to my blob Xnerv Surveys "},"merge-intervals/":{"url":"merge-intervals/","title":"56. Merge Intervals","keywords":"","body":"【LeetCode with Python】 56. Merge Intervals题目分析代码【LeetCode with Python】 56. Merge Intervals tagsstart Hard Problems Array Sort tagsstop 题目 原题页面：https://leetcode.com/problems/merge-intervals/ 本文地址：http://leetcode.xnerv.wang/merge-intervals/ 题目类型：Array, Sort 难度评价：Hard 类似题目：(H) Insert Interval, (E) Meeting Rooms, (M) Meeting Rooms II Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 分析 合并相连的区间。基本思路是，首先按起点start对所有区间排序，然后通过一次遍历来合并相连的区间。 代码 class Interval: def __init__(self, s=0, e=0): self.start = s self.end = e class Solution: # @param intervals, a list of Interval # @return a list of Interval def merge(self, intervals): if len(intervals) = last_interval.start and intervals[i].start = last_interval.start and intervals[i].end Welcome to my blob Xnerv Surveys "},"insert-interval/":{"url":"insert-interval/","title":"57. Insert Interval","keywords":"","body":"【LeetCode with Python】 57. Insert Interval题目分析代码【LeetCode with Python】 57. Insert Interval tagsstart Hard Problems Array Sort tagsstop 题目 原题页面：https://leetcode.com/problems/insert-interval/ 本文地址：http://leetcode.xnerv.wang/insert-interval/ 题目类型：Array, Sort 难度评价：Hard 类似题目：(H) Merge Intervals Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 分析 首先要找到newInterval在已有数组中的位置。有三种可能： newInterval与已有数组没有交集，位于数组最左端，即left_index=0，right_index=-1。此时直接将newInterval插入到数组头部即可。 newInterval与已有数组没有交集，位于数组最右端，即left_index=-1。此时直接将newInterval插入到数组尾部即可。 newInterval与已有数组有交集，这是最普遍的一种情况。newInterval可能是和数组中已有的一个interval有交集，也有可能是跨了几个interval。此时left_index表示数组中右值>=newInterval的左值的最大的interval（约定在数轴上越靠右的interval最大），而right_index表示数组中左值 代码 class Solution: # @param intervals, a list of Intervals # @param newInterval, a Interval # @return a list of Interval def insert(self, intervals, newInterval): len_intervals = len(intervals) if 0 == len_intervals: return [ newInterval ] left_index = -1 right_index = -1 find_left = False for m in range(0, len_intervals): if not find_left and newInterval.start = intervals[m].start: right_index = m if -1 == left_index: ### intervals.append(newInterval) return intervals new_intervals = [ ] for m in range(0, left_index): new_intervals.append(intervals[m]) add_interval = None start_index = -1 if -1 != right_index: add_interval = Interval(min(newInterval.start, intervals[left_index].start), max(newInterval.end, intervals[right_index].end)) start_index = right_index + 1 else: ### add_interval = newInterval start_index = left_index new_intervals.append(add_interval) for m in range(start_index, len_intervals): new_intervals.append(intervals[m]) return new_intervals Welcome to my blob Xnerv Surveys "},"length-of-last-word/":{"url":"length-of-last-word/","title":"58. Length of Last Word","keywords":"","body":"【LeetCode with Python】 58. Length of Last Word题目分析代码【LeetCode with Python】 58. Length of Last Word tagsstart Easy Problems String tagsstop 题目 原题页面：https://leetcode.com/problems/length-of-last-word/ 本文地址：http://leetcode.xnerv.wang/length-of-last-word/ 题目类型：String 难度评价：Easy Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = \"Hello World\", return 5. 分析 计算一句话中最后一个单词的长度。这道题很简单，但陷阱就在于要注意处理好一些异常或边界情形，如空串，最后一个单词后面还有空白等等。 代码 class Solution: # @param s, a string # @return an integer def lengthOfLastWord(self, s): len_s = len(s) if 0 == len_s: return 0 index = len_s - 1 while index >= 0 and ' ' == s[index]: index -= 1 len_last_word = 0 while index >= 0 and ' ' != s[index]: len_last_word += 1 index -= 1 return len_last_word Welcome to my blob Xnerv Surveys "},"spiral-matrix-ii/":{"url":"spiral-matrix-ii/","title":"59. Spiral Matrix II","keywords":"","body":"【LeetCode with Python】 59. Spiral Matrix II题目分析代码【LeetCode with Python】 59. Spiral Matrix II tagsstart Medium Problems Array tagsstop 题目 原题页面：https://oj.leetcode.com/problems/spiral-matrix-ii/ 本文地址：http://leetcode.xnerv.wang/spiral-matrix-ii/ 题目类型：Array 难度评价：Medium 类似题目：(M) Spiral Matrix Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. For example, Given n = 3, You should return the following matrix: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 分析 跟(M) Spiral Matrix类似，使用两重for循环，但不是输出螺旋状遍历的元素，而是螺旋状地将元素填入到二维数组中。 代码 class Solution: # @return a list of lists of integer def generateMatrix(self, n): if 0 == n: return [ ] m = n index = 1 matrix = [[0 for x in range(0, n)] for y in range(0, n)] round = (n + 1) / 2 for x in range(0, round): for y in range(x, n - x): matrix[x][y] = index index += 1 for y in range(x + 1, m - x - 1): matrix[y][n - x - 1] = index index += 1 if m - 2 * x > 1: ### for y in range(n - x - 1, x - 1, -1): matrix[m - x - 1][y] = index index += 1 if n - 2 * x > 1: ### for y in range(m - x - 2, x, -1): ### matrix[y][x] = index index += 1 return matrix Welcome to my blob Xnerv Surveys "},"rotate-list/":{"url":"rotate-list/","title":"61. Rotate List","keywords":"","body":"【LeetCode with Python】 61. Rotate List题目分析代码【LeetCode with Python】 61. Rotate List tagsstart Medium Problems Linked List Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/rotate-list/ 本文地址：http://leetcode.xnerv.wang/rotate-list/ 题目类型：Linked List, Two Pointers 难度评价：Medium 类似题目：(E) Rotate Array Given a list, rotate the list to the right by k places, where k is non-negative. For example: Given 1->2->3->4->5->NULL and k = 2, return 4->5->1->2->3->NULL. 分析 这类链表倒置，或链表局部倒置的题目，都是大学数据结构课程的日常题目。一般要注意三点： 在必要的head/tail处设置指针，便于操作； 注意当节点数n为0、1、2等时的特殊情况下的处理，记得检查指针是否为None； 有时候head或tail需要特殊处理，此时可以通过增加一个new_head或new_tail，使得head或tail可以被当成普通节点来处理。 代码 class Solution: # @param head, a ListNode # @param k, an integer # @return a ListNode def rotateRight(self, head, k): if None == head or None == head.next: return head cur_head = head cur = head while k > 0: cur = cur.next if None == cur: return head k -= 1 cur_tail = cur cur_head = cur.next if None == cur_head: return head cur = cur_head while None != cur.next: cur = cur.next cur.next = head cur_tail.next = None return cur_head Welcome to my blob Xnerv Surveys "},"unique-paths/":{"url":"unique-paths/","title":"62. Unique Paths","keywords":"","body":"【LeetCode with Python】 62. Unique Paths题目分析代码【LeetCode with Python】 62. Unique Paths tagsstart Medium Problems Array Dynamic Programming tagsstop 题目 原题页面：https://leetcode.com/problems/unique-paths/ 本文地址：http://leetcode.xnerv.wang/unique-paths/ 题目类型：Array, Dynamic Programming 难度评价：Medium 类似题目：(M) Unique Paths II, (M) Minimum Path Sum, (H) Dungeon Game A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100. 分析 用数学中的排列组合来解题，从(m+n)次选择中选出m次向下走。 这道题跟“n阶台阶，每次一步或两步，总共多少种走法”一样，也可以用动态规划解题，不过这里是二维动态规划，而后者是一维动态规划。Unique Paths还比较简单，所以可用排列组合快速解题，但是Unique Paths II这道题，就只能用动态规划了。 代码 class Solution: # @return an integer def uniquePaths(self, m, n): if 0 == m or 0 == n: return 1 up = 1 for i in range(m + n - 2, n - 1, -1): up *= i down = 1 for j in range(1, m): down *= j return up / down Welcome to my blob Xnerv Surveys "},"valid-number/":{"url":"valid-number/","title":"65. Valid Number","keywords":"","body":"【LeetCode with Python】 65. Valid Number题目分析代码【LeetCode with Python】 65. Valid Number tagsstart Hard Problems Math String tagsstop 题目 原题页面：https://oj.leetcode.com/problems/valid-number/ 本文地址：http://leetcode.xnerv.wang/valid-number/ 题目类型：Math, String 难度评价：hard 类似题目：(E) String to Integer (atoi) Validate if a given string is numeric. Some examples: \"0\" => true \" 0.1 \" => true \"abc\" => false \"1 a\" => false \"2e10\" => true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. 分析 有穷自动机DFA。话说这题用NFA可以解吗？NFA的使用局限是什么？ 代码 class Solution: def getType(self, ch): if '^' == ch: return 0 elif ' ' == ch: return 1 elif '+' == ch or '-' == ch: return 2 elif ch >= '0' and ch Welcome to my blob Xnerv Surveys "},"plus-one/":{"url":"plus-one/","title":"66. Plus One","keywords":"","body":"【LeetCode with Python】 66. Plus One题目分析代码【LeetCode with Python】 66. Plus One tagsstart Easy Problems Array Math tagsstop 题目 原题页面：https://leetcode.com/problems/plus-one/ 本文地址：http://leetcode.xnerv.wang/plus-one/ 题目类型：Array, Math 难度评价：Easy 类似题目：(M) Multiply Strings, (E) Add Binary Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. 分析 用一个int数组代表一个数值，最左边是最高位，现要求加上1，同样地返回一个int数组代表计算结果。 非常简单的模拟加法，注意进位问题，如果是99，999这种，最后加上1后还要在数组最左边插入一个元素1。 无论最高位有没有发生进位，空间复杂度都是O(1)。时间复杂度是O(N)。 代码 class Solution: # @param digits, a list of integer digits # @return a list of integer digits def plusOne(self, digits): len_s = len(digits) carry = 1 for i in range(len_s - 1, -1, -1): total = digits[i] + carry digit = int(total % 10) carry = int(total / 10) digits[i] = digit if 1 == carry: digits.insert(0, 1) return digits Welcome to my blob Xnerv Surveys "},"add-binary/":{"url":"add-binary/","title":"67. Add Binary","keywords":"","body":"【LeetCode with Python】 67. Add Binary题目分析代码【LeetCode with Python】 67. Add Binary tagsstart Easy Problems Math String tagsstop 题目 原题页面：https://leetcode.com/problems/add-binary/ 本文地址：http://leetcode.xnerv.wang/add-binary/ 题目类型：Math, String 难度评价：Easy 类似题目：(M) Add Two Numbers, (M) Multiply Strings, (E) Plus One Given two binary strings, return their sum (also a binary string). For example, a = \"11\" b = \"1\" Return \"100\". 分析 用字符串模拟二进制整数加法。写了一个更通用的算法，修改self.radix即可将代码改为如八进制整数加法、十进制整数加法等。 但是在实现过程中，为了处理上的方便，以及为了让代码更简洁，对两个加数的数组做了补零的操作。否则还得分a比b长，b比a长，a和b一样长3种case来处理，代码可能会比较繁琐。 （由于这里是用Python实现，所以直接用字符串相加这种直观的写法。但实际上从算法效率上考虑，应该实现申请一个size=max(len(a), len(b))+1的字符数组，然后在这个数组中进行模拟加法。 代码 class Solution: def __init__(self): self.radix = 2 # @param a, a string # @param b, a string # @return a string def addBinary(self, a, b): a_nums = [(ord(ch) - ord('0')) for ch in a] b_nums = [(ord(ch) - ord('0')) for ch in b] a_nums_size = len(a_nums) b_nums_size = len(b_nums) max_nums_size = max(a_nums_size, b_nums_size) a_extend_nums = [0 for i in range(0, max_nums_size - a_nums_size)] b_extend_nums = [0 for i in range(0, max_nums_size - b_nums_size)] a_nums = a_extend_nums + a_nums b_nums = b_extend_nums + b_nums sum_nums = [0] * max_nums_size carry = 0 for i in range(max_nums_size - 1, -1, -1): sum = a_nums[i] + b_nums[i] + carry sum_nums[i] = sum % self.radix carry = sum / self.radix sum_str = (\"1\" if 1 == carry else \"\") for i in range(0, max_nums_size): sum_str += chr(sum_nums[i] + ord('0')) return sum_str Welcome to my blob Xnerv Surveys "},"climbing-stairs/":{"url":"climbing-stairs/","title":"70. Climbing Stairs","keywords":"","body":"【LeetCode with Python】 70. Climbing Stairs题目分析代码【LeetCode with Python】 70. Climbing Stairs tagsstart Easy Problems Dynamic Programming tagsstop 题目 原题页面：https://leetcode.com/problems/climbing-stairs/ 本文地址：http://leetcode.xnerv.wang/climbing-stairs/ 题目类型：Dynamic Programming 难度评价：Easy You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 分析 如果按照从右至左的逆序递归求解，其实就相当于搜索算法了，会造成子搜索过程的重复计算。搜索算法一般都可以用动态规划来替代，因此这里就用1D动态规划。 f(x)的求解，用归纳法进行推导。如果n=1，则f(1)=2；如果n=2，可以走1个1步，也可以走2个1步，则f(2)=2；如果n=3，如果一开始走1步，则有f(2)种走法，如果一开始走2步，则有f(1)种走法；如果n=4，如果一开始走1步，则右f(3)种走法，如果一开始有2步，则有f(2)种走法。由此可以推导出一个公式：f(x)=f(x-1)+f(x-2)，可以用数学归纳法进行证明。 然后可以发现，由于f(x)的求解只依赖于f(x-1)和f(x-2)，因此可以将空间复杂度缩小到int[3]。于是你就会进一步发现，这其实就是一个裴波拉契数列问题。 代码 class Solution: # @param n, an integer # @return an integer def climbStairs(self, n): if n Welcome to my blob Xnerv Surveys "},"simplify-path/":{"url":"simplify-path/","title":"71. Simplify Path","keywords":"","body":"【LeetCode with Python】 71. Simplify Path题目分析代码【LeetCode with Python】 71. Simplify Path tagsstart Medium Problems Stack String tagsstop 题目 原题页面：https://oj.leetcode.com/problems/simplify-path/ 本文地址：http://leetcode.xnerv.wang/simplify-path/ 题目类型：Stack, String 难度评价：Medium Given an absolute path for a file (Unix-style), simplify it. For example, path = \"/home/\", => \"/home\" path = \"/a/./b/../../c/\", => \"/c\" Corner Cases: Did you consider the case where path = \"/../\"? In this case, you should return \"/\". Another corner case is the path might contain multiple slashes '/' together, > such as \"/home//foo/\". In this case, you should ignore redundant slashes and return \"/home/foo\". 分析 用栈分析Linux路径，得出最后的结果。需要注意的就是Corner Cases了，如果是Windows用的相对较多的同学，很可能就不会注意到这些细节。但实际上很多涉及路径的win32 API也支持这种Corner Cases。 代码 class Solution: # @param path, a string # @return a string def simplifyPath(self, path): stack = [ ] toks = path.split(\"/\") stack.append(toks[0]) toks = toks[1:] for tok in toks: if tok in (\"\", \".\"): continue elif \"..\" == tok: if len(stack) > 0 and \"\" != stack[len(stack) - 1]: # root / should not be poped to distinguish abs path and rel path stack.pop() #else: # return \"\" # /home/../../.. else: stack.append(tok) len_stack = len(stack) if len_stack >1: return \"/\".join(stack) if \"\" == stack[0] else \"/\" + \"/\".join(stack) elif (1 == len_stack and \"\" == stack[0]) or 0 == len_stack: return \"/\" Welcome to my blob Xnerv Surveys "},"edit-distance/":{"url":"edit-distance/","title":"72. Edit Distance","keywords":"","body":"【LeetCode with Python】 72. Edit Distance题目分析代码【LeetCode with Python】 72. Edit Distance tagsstart Hard Problems Dynamic Programming String tagsstop 题目 原题页面：https://leetcode.com/problems/edit-distance/ 本文地址：http://leetcode.xnerv.wang/edit-distance/ 题目类型：Dynamic Programming, String 难度评价：Hard 类似题目：(M) One Edit Distance Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a character b) Delete a character c) Replace a character 分析 一道传统意义上的经典的动态规划题目。注意动态规划十有八九可以优化空间复杂度，不是真的要开辟一个(m+1)(n+1)的大矩阵出来。目前用的解法已经减小到了两行，可以继续优化到22的小矩阵。 对于这个DP矩阵，每个方格代表当前子问题的最佳解决方案。如果每个方格记录下自身是基于如何从上一层子问题的最佳解决方案推进而来，则通过这层线索，可以从指定的一个方格，反向推演出当前最佳方案的整个构成路径。如果一个方法的最佳解决方案不只一个，则构成路径变成了一棵树。 DP矩阵的第0行和第0列一般都要特别处理。 此外，DP的题目最好能习惯于写出DP递推方程，这样可以用更简洁的公式来解释思路： d[0, j] = j d[i, 0] = i d[i, j] = d[i-1, j - 1] if A[i] == B[j] d[i, j] = min(d[i-1, j - 1], d[i, j - 1], d[i-1, j]) + 1 if A[i] != B[j] 代码 class Solution: # @return an integer def minDistance(self, word1, word2): if \"\" == word1 and \"\" == word2: return 0 elif \"\" == word1: return len(word2) elif \"\" == word2: return len(word1) len1 = len(word1) len2 = len(word2) arr1 = [0 for y in range(0, len1 + 1)] arr2 = [0 for y in range(0, len1 + 1)] arr1[0] = 0 for y in range(1, len1 + 1): arr1[y] = y for x in range(1, len2 + 1): arr2[0] = x for y in range(1, len1 + 1): arr2[y] = min(arr1[y - 1] + (0 if (word1[y - 1] == word2[x - 1]) else 1), arr1[y] + 1, arr2[y - 1] + 1) tmp = arr1 arr1 = arr2 arr2 = tmp for y in range(0, len1 + 1): arr2[y] = 0 return arr1[len1] Welcome to my blob Xnerv Surveys "},"set-matrix-zeroes/":{"url":"set-matrix-zeroes/","title":"73. Set Matrix Zeroes","keywords":"","body":"【LeetCode with Python】 73. Set Matrix Zeroes题目分析代码【LeetCode with Python】 73. Set Matrix Zeroes tagsstart Medium Problems Array tagsstop 题目 原题页面：https://leetcode.com/problems/set-matrix-zeroes/ 本文地址：http://leetcode.xnerv.wang/set-matrix-zeroes/ 题目类型：Array 难度评价：Medium 类似题目：(M) Game of Life Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up: Did you use extra space? A straight forward solution using O(m**n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 分析 看到这题的第一个想到的最简单的算法是，做一次m*n的遍历，每次遇到0，就将所在的行和列的元素给清零了，显然这样可能大量的重复清零。 然后想到的是，不应该在遍历的过程中就开始清零，而是应该记录下应该清零哪些行和列，这样再遍历完成后再一次性地完成清零工作。于是就需要空间来记录所有行和列是否需要清零。 但是题目又要求不能使用额外空间，于是就只可能用原有的矩阵来进行记录。如果一个点(x,y)=0，则将(x,0)和(0,y)标记为0，表示第x列和第y行需要清零。 但是，假如第二行的第一个元素是0，则会导致(0,0)标记为0，这样会使得第一行和第一列被清零，显然此时第一行被清零是不应该的。我这里采用的做法是，对于第一行和第一列是否需要清零，用两个额外的变量来标记。我尝试了很久，希望能通过使用点(m-1,n-1)，从而去除掉这两个额外变量，但试了很久都没有实现，以后还会继续思考是否可行。不过因为题目要求的是常量空间，所以现在这种算法已经符合要求了。 代码 class Solution: # @param matrix, a list of lists of integers # RETURN NOTHING, MODIFY matrix IN PLACE. def setZeroes(self, matrix): if None == matrix or [ ] == matrix or None == matrix[0] or [ ] == matrix[0]: return firstrow_clear = False ### firstcol_clear = False len_x = len(matrix) len_y = len(matrix[0]) for i in range(0, len_x): for j in range(0, len_y): if 0 == matrix[i][j]: matrix[i][0] = 0 matrix[0][j] = 0 if 0 == i: firstrow_clear = True if 0 == j: firstcol_clear = True for i in range(1, len_x): if 0 == matrix[i][0]: for j in range(0, len_y): matrix[i][j] = 0 for j in range(1, len_y): if 0 == matrix[0][j]: for i in range(0, len_x): matrix[i][j] = 0 if firstcol_clear: for i in range(1, len_x): matrix[i][0] = 0 if firstrow_clear: for j in range(1, len_y): matrix[0][j] = 0 Welcome to my blob Xnerv Surveys "},"sort-colors/":{"url":"sort-colors/","title":"75. Sort Colors","keywords":"","body":"【LeetCode with Python】 75. Sort Colors题目分析代码【LeetCode with Python】 75. Sort Colors tagsstart Medium Problems Array Two Pointers Sort tagsstop 题目 原题页面：https://oj.leetcode.com/problems/sort-colors/ 本文地址：http://leetcode.xnerv.wang/sort-colors/ 题目类型：Array, Two Pointers, Sort 难度评价：Medium 类似题目：(M) Sort List, (M) Wiggle Sort Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with an one-pass algorithm using only constant space? 分析 定义两个两头的下标left和right，i从左至右遍历数组，发现0就和left交换（同时left+=1），发现2就和right交换（同时right-=1）。这样就能确保下标 right的元素都是2。 还可以进行进一步的优化，left指针每次都移动到一个不是0的位置，right指针每次都移动到一个不是2的位置，这样也许可以减少一些交换次数。 代码 class Solution: # @param A a list of integers # @return nothing, sort in place def sortColors(self, A): len_A = len(A) if 1 == len(A): return left = 0 right = len_A - 1 i = 0 while i Welcome to my blob Xnerv Surveys "},"combinations/":{"url":"combinations/","title":"77. Combinations","keywords":"","body":"【LeetCode with Python】 77. Combinations题目分析代码【LeetCode with Python】 77. Combinations tagsstart Medium Problems Backtracking tagsstop 题目 原题页面：https://leetcode.com/problems/combinations/ 本文地址：http://leetcode.xnerv.wang/combinations/ 题目类型：Backtracking 难度评价：Medium 类似题目：(M) Combination Sum, (M) Permutations Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 分析 一道普通的递归回溯的问题。这类问题要考虑两个因素：一是做出分支的依据因素，一是结束递归的条件。 在这道题目中，做出分支的依据是：是否选择当前的元素。结束递归的条件是：已选择了k个元素，或虽然不足k个元素但已经遍历完全部元素。后面这一个条件尤其要注意，如果忘了加上的话，往往会导致无穷递归（类似于死循环）。 代码 class Solution: def __init__(self): self.lists = [ ] def doCombine(self, list, n, m, k): if 0 == k: self.lists.append(list) return if m > n: return self.doCombine(list[:], n, m + 1, k) new_list = list new_list.append(m) self.doCombine(new_list, n, m + 1, k - 1) # @return a list of lists of integers def combine(self, n, k): if k > n: return [ ] self.doCombine([ ], n, 1, k) return self.lists Welcome to my blob Xnerv Surveys "},"subsets/":{"url":"subsets/","title":"78. Subsets","keywords":"","body":"【LeetCode with Python】 78. Subsets题目分析代码【LeetCode with Python】 78. Subsets tagsstart Medium Problems Array Backtracking Bit Manipulation tagsstop 题目 原题页面：https://leetcode.com/problems/subsets/ 本文地址：http://leetcode.xnerv.wang/subsets/ 题目类型：Array, Backtracking, Bit Manipulation 难度评价：Medium Given a set of distinct integers, nums, return all possible subsets. Note: Elements in a subset must be in non-descending order. The solution set must not contain duplicate subsets. For example, If nums = [1,2,3], a solution is: [[3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 分析 普通的搜索算法即可解决，不过注意每个子序列都要以升序排列，所以从一开始就把输入的S排好序，一了百了，不知道是否还有其它更好的算法。 递归回溯的两个关键：递和归。递即分支条件，在本题里指的是是否选择某个元素，而形成每次的两个分支。归即结束条件，在本题里指已经考察完全部元素。 代码 class Solution: def __init__(self): self.results = [ ] def doSubsets(self, S, cur_list, cur_index): if cur_index > len(S) - 1: self.results.append(cur_list) return cur_list0 = cur_list[:] cur_list1 = cur_list[:] cur_list1.append(S[cur_index]) self.doSubsets(S, cur_list0, cur_index + 1) self.doSubsets(S, cur_list1, cur_index + 1) # @param S, a list of integer # @return a list of lists of integer def subsets(self, S): S.sort() self.doSubsets(S, [ ], 0) return self.results Welcome to my blob Xnerv Surveys "},"remove-duplicates-from-sorted-array-ii/":{"url":"remove-duplicates-from-sorted-array-ii/","title":"80. Remove Duplicates from Sorted Array II","keywords":"","body":"【LeetCode with Python】 80. Remove Duplicates from Sorted Array II题目分析代码【LeetCode with Python】 80. Remove Duplicates from Sorted Array II tagsstart Medium Problems Array Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ 本文地址：http://leetcode.xnerv.wang/remove-duplicates-from-sorted-array-ii/ 题目类型：Array, Two Pointers 难度评价：Medium Follow up for \"Remove Duplicates\": What if duplicates are allowed at most twice? For example, Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length. 分析 和Remove Duplicates from Sorted Array类似，只是一个元素可以重复出现最多两次，因此可以模仿Remove Duplicates from Sorted List II的解法。 代码 class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if None == A: return 0 len_A = len(A) if len_A = 2: count += 1 else: m += 1 count += 1 if m != n: A[m] = A[n] n += 1 return m + 1 Welcome to my blob Xnerv Surveys "},"remove-duplicates-from-sorted-list-ii/":{"url":"remove-duplicates-from-sorted-list-ii/","title":"82. Remove Duplicates from Sorted List II","keywords":"","body":"【LeetCode with Python】 82. Remove Duplicates from Sorted List II题目分析代码【LeetCode with Python】 82. Remove Duplicates from Sorted List II tagsstart Medium Problems Linked List tagsstop 题目 原题页面：https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ 本文地址：http://leetcode.xnerv.wang/remove-duplicates-from-sorted-list-ii/ 题目类型：Linked List 难度评价：Medium Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example, Given 1->2->3->3->4->4->5, return 1->2->5. Given 1->1->1->2->3, return 2->3. 分析 和Remove Duplicates from Sorted List差不多的题目，区别是对于重复的元素不是去重，而是完全地删除重复出现过的元素。 代码 class Solution: # @param head, a ListNode # @return a ListNode def deleteDuplicates(self, head): if None == head or None == head.next: return head new_head = ListNode(-1) new_head.next = head parent = new_head cur = head while None != cur and None != cur.next: ### check cur.next None if cur.val == cur.next.val: val = cur.val while None != cur and val == cur.val: ### check cur None cur = cur.next parent.next = cur else: cur = cur.next parent = parent.next return new_head.next Welcome to my blob Xnerv Surveys "},"remove-duplicates-from-sorted-list/":{"url":"remove-duplicates-from-sorted-list/","title":"83. Remove Duplicates from Sorted List","keywords":"","body":"【LeetCode with Python】 83. Remove Duplicates from Sorted List题目分析代码【LeetCode with Python】 83. Remove Duplicates from Sorted List tagsstart Easy Problems Linked List tagsstop 题目 原题页面：https://leetcode.com/problems/remove-duplicates-from-sorted-list/ 本文地址：http://leetcode.xnerv.wang/remove-duplicates-from-sorted-list/ 题目类型：Linked List 难度评价：Easy Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1->1->2, return 1->2. Given 1->1->2->3->3, return 1->2->3. 分析 有序链表的去重，注意及时检查一些引用是否为None。 代码 class Solution: # @param head, a ListNode # @return a ListNode def deleteDuplicates(self, head): if None == head or None == head.next: return head cur = head while None != cur: if None != cur.next and cur.val == cur.next.val: cur.next = cur.next.next continue else: cur = cur.next return head Welcome to my blob Xnerv Surveys "},"partition-list/":{"url":"partition-list/","title":"86. Partition List","keywords":"","body":"【LeetCode with Python】 86. Partition List题目分析代码【LeetCode with Python】 86. Partition List tagsstart Medium Problems Linked List Two Pointers tagsstop 题目 原题页面：https://oj.leetcode.com/problems/partition-list/ 本文地址：http://leetcode.xnerv.wang/partition-list/ 题目类型：Linked List, Two Pointers 难度评价：Medium Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example, Given 1->4->3->2->5->2 and x = 3, return 1->2->2->4->3->5. 分析 代码 class Solution: # @param head, a ListNode # @param x, an integer # @return a ListNode def partition(self, head, x): if None == head or None == head.next: return head new_head = ListNode(-1) new_head.next = head tail = head while None != tail.next: tail = tail.next cur = head parent = new_head l_pos = new_head while tail != parent and None != cur: if cur.val >= x: break parent = parent.next cur = cur.next l_pos = l_pos.next parent = parent.next if None != cur: cur = cur.next #l_pos = l_pos.next while tail != parent and None != cur: if cur.val Welcome to my blob Xnerv Surveys "},"merge-sorted-array/":{"url":"merge-sorted-array/","title":"88. Merge Sorted Array","keywords":"","body":"【LeetCode with Python】 88. Merge Sorted Array题目分析代码【LeetCode with Python】 88. Merge Sorted Array tagsstart Easy Problems Array Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/merge-sorted-array/ 本文地址：http://leetcode.xnerv.wang/merge-sorted-array/ 题目类型：Array, Two Pointers 难度评价：Easy 类似题目：(E) Merge Two Sorted Lists Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is > greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 分析 将一个有序数组B合并到另一个有序数组A。这题如果从数组头开始合并，则每一次都要整体移动数组A后面的元素，显然不是理想的方法。一种巧妙的做法是从两个数组尾部开始合并，这样就避免了大面积的数组元素移动。 代码 class Solution: # @param A a list of integers # @param m an integer, length of A # @param B a list of integers # @param n an integer, length of B # @return nothing def merge(self, A, m, B, n): if 0 == n: return A if 0 == m: for i in range(0, n): A[i] = B[i] return A index = m + n - 1 indexA = m - 1 indexB = n - 1 while indexA >= 0 and indexB >= 0: if A[indexA] >= B[indexB]: A[index] = A[indexA] index -= 1 indexA -= 1 else: A[index] = B[indexB] index -= 1 indexB -= 1 if indexA >= 0: pass else: for i in range(0, indexB + 1): A[i] = B[i] Welcome to my blob Xnerv Surveys "},"subsets-ii/":{"url":"subsets-ii/","title":"90. Subsets II","keywords":"","body":"【LeetCode with Python】 90. Subsets II题目分析代码【LeetCode with Python】 90. Subsets II tagsstart Medium Problems Array Backtracking tagsstop 题目 原题页面：https://leetcode.com/problems/subsets-ii/ 本文地址：http://leetcode.xnerv.wang/subsets-ii/ 题目类型：Array, Backtracking 难度评价：Medium Given a collection of integers that might contain duplicates,nums, return all possible subsets. Note: Elements in a subset must be in non-descending order. The solution set must not contain duplicate subsets. For example, If nums = [1,2,2], a solution is: [[2], [1], [1,2,2], [2,2], [1,2], [] ] 分析 与Subsets差不多，先对输入的列表S排序，唯一需要改动的是只是需要在每次递归的时候记忆前一个字符，从而避免一种情况：相等的字符，如果前一个没有才采纳，则后面的字符则也不能被采纳，通过这种方式可以避免产生重复的子序列。 代码 class Solution: def __init__(self): self.results = [ ] def doSubsets(self, S, cur_list, cur_index, last_ch, add_last_ch): if cur_index > len(S) - 1: self.results.append(cur_list) return cur_list0 = cur_list[:] self.doSubsets(S, cur_list0, cur_index + 1, S[cur_index], False) if not last_ch == S[cur_index] or add_last_ch: cur_list1 = cur_list[:] cur_list1.append(S[cur_index]) self.doSubsets(S, cur_list1, cur_index + 1, S[cur_index], True) # @param num, a list of integer # @return a list of lists of integer def subsetsWithDup(self, S): S.sort() self.doSubsets(S, [ ], 0, \"\", False) return self.results Welcome to my blob Xnerv Surveys "},"decode-ways/":{"url":"decode-ways/","title":"91. Decode Ways","keywords":"","body":"【LeetCode with Python】 91. Decode Ways题目分析代码【LeetCode with Python】 91. Decode Ways tagsstart Medium Problems Dynamic Programming String tagsstop 题目 原题页面：https://leetcode.com/problems/decode-ways/ 本文地址：http://leetcode.xnerv.wang/decode-ways/ 题目类型：Dynamic Programming, String 难度评价：Medium A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example, Given encoded message \"12\", it could be decoded as \"AB\" (1 2) or \"L\" (12). The number of ways decoding \"12\" is 2. 分析 （这个应该是一个一维DP问题，本质是裴波拉契数列，为什么我用了两行？？？） DP问题，需要注意的除了边界条件的处理，还有关于'0'的注意点。'0'本身可以构成'10'，'20'这样合法的双字节码，但其它情况的'0'就是异常数据了。这道题目跟atoi一样，都属于题意描述不清晰，题意本身并没有说清楚要“尽量多地解码出字符串”，因此一开始我一旦发现有多余的'0'就直接认为解码失败范围0，结果提交后发现不对。此外，输入的参数s也可能是个空串，从验证的结果看来这种情况下应该返回0，题目也没有说清楚。 另外对于很大一部分DP题目，内存都是可以优化的，这里也不必采用n 2大小的二维数组，只需保留两行，即2 2的空间消耗即可。 最后，还要特别说明一下新学到的一招。起先还想像C语言一样写个swap函数，用一个临时变量tmp来交换solu_arr1和solu_arr2两个引用，后来发现竟然可以用solu_arr1, solu_arr2 = solu_arr2, solu_arr1这种简便的写法，大赞Python！（同时也说明了我学Python是半路出家……） 代码 class Solution: # @param s, a string # @return an integer def numDecodings(self, s): if None == s or 0 == len(s) or '0' == s[0]: return 0 solu_arr1 = [0, 1] solu_arr2 = [0, 0] for i in range(1, len(s) + 1): cur_ch = s[i - 1] last_ch = s[i - 2] if 1 != i else '' if cur_ch >= '1' and cur_ch 26: solu_arr2[1] = 0 else: solu_arr2[1] = solu_arr1[0] solu_arr1, solu_arr2 = solu_arr2, solu_arr1 # swap return solu_arr1[0] + solu_arr1[1] Welcome to my blob Xnerv Surveys "},"reverse-linked-list-ii/":{"url":"reverse-linked-list-ii/","title":"92. Reverse Linked List II","keywords":"","body":"【LeetCode with Python】 92. Reverse Linked List II题目分析代码【LeetCode with Python】 92. Reverse Linked List II tagsstart Medium Problems Linked List tagsstop 题目 原题页面：https://leetcode.com/problems/reverse-linked-list-ii/ 本文地址：http://leetcode.xnerv.wang/reverse-linked-list-ii/ 题目类型：Linked List 难度评价：Medium 类似题目：(E) Reverse Linked List Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL. Note: Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list. 分析 反转链表中的一部分。貌似写出来的代码有点长，也许可以优化。 代码 class Solution: # @param head, a ListNode # @param m, an integer # @param n, an integer # @return a ListNode def reverseBetween(self, head, m, n): if m == n: return head m_is_head = True if 1 == m else False if False == m_is_head: m_pre_node = head for i in range(0, m - 1 - 1): m_pre_node = m_pre_node.next m_node = m_pre_node.next else: m_node = head n_node = m_node for i in range(0, n - m): n_node = n_node.next n_next_node = n_node.next if False == m_is_head: m_pre_node.next = n_node p1_node = m_node p2_node = p1_node.next p3_node = p2_node.next while n_node != p1_node: p2_node.next = p1_node p1_node = p2_node p2_node = p3_node if None == p2_node: break p3_node = p3_node.next m_node.next = n_next_node return n_node if m_is_head else head Welcome to my blob Xnerv Surveys "},"restore-ip-addresses/":{"url":"restore-ip-addresses/","title":"93. Restore IP Addresses","keywords":"","body":"【LeetCode with Python】 93. Restore IP Addresses题目分析代码【LeetCode with Python】 93. Restore IP Addresses tagsstart Medium Problems Backtracking String tagsstop 题目 原题页面：https://leetcode.com/problems/restore-ip-addresses/ 本文地址：http://leetcode.xnerv.wang/restore-ip-addresses/ 题目类型：Backtracking, String 难度评价：Medium Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given \"25525511135\", return [\"255.255.11.135\", \"255.255.111.35\"]. (Order does not matter) 分析 （这道题可以用DP来解答么？？？） 搜索，递归，剪枝。 注意剪枝条件：1.每个域的数值不能大于255；2.有且刚好4个域；3.一个域的长度>=2时，不能以0开头。因此逻辑结构如下： 如果当前考察字符不是最后一个字符 如果当前字符附加到当前已有数据域（num）后面，数据域新值不大于255时 如果当前出现的小数点数目（fields）小于3，则可以考虑直接在已有前缀（prefix）后面加一个小数点，然后以当前字符开头，开始新的数据域 如果当前已有数据域不是0，则可以考虑将本字符直接附加到当前已有数据域 2 否则，就看当前小数点数目是不是小于3，小于就可以考虑直接在已有前缀（prefix）后面加一个小数点，然后以当前字符开头，开始新的数据域 否则则本分支失败 如果当前考察字符是最后一个字符 如果当前已有有三个小数点，当前数据域不是0，并且将当前字符附加到当前数据域后面，数据域新值也不会大于255时，可以考虑这样做 否则如果当前已有两个小数点，则用小数点结束当前数据域，然后以当前字符作为最后一个数据域从而构成一个解 否则当前分支失败 代码 class Solution: def doRestoreIpAddresses(self, prefix, num, s, start, fields): if start == len(s) - 1: results1 = [ ] results2 = [ ] if int(num + s[start]) Welcome to my blob Xnerv Surveys "},"binary-tree-inorder-traversal/":{"url":"binary-tree-inorder-traversal/","title":"94. Binary Tree Inorder Traversal","keywords":"","body":"【LeetCode with Python】 94. Binary Tree Inorder Traversal题目分析代码【LeetCode with Python】 94. Binary Tree Inorder Traversal tagsstart Medium Problems Tree Hash Table Stack tagsstop 题目 原题页面：https://leetcode.com/problems/binary-tree-inorder-traversal/ 本文地址：http://leetcode.xnerv.wang/binary-tree-inorder-traversal/ 题目类型：Tree, Hash Table, Stack 难度评价：Medium 类似题目：(M) Validate Binary Search Tree, (M) Binary Tree Preorder Traversal, (H) Binary Tree Postorder Traversal, (M) Binary Search Tree Iterator, (M) Kth Smallest Element in a BST, (H) Closest Binary Search Tree Value II, (M) Inorder Successor in BST Given a binary tree, return the inorder traversal of its nodes' values. For example: Given binary tree {1,#,2,3}, 1 \\ 2 / 3 return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? confused what \"{1,#,2,3}\" means? OJ's Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". 分析 非递归中序遍历二叉树，每一个计算机和软件专业的朋友大学上数据结构时都会遇到的题之一。总结成一句话就是：有左节点时将左节点压栈，无左节点时出栈一个元素（栈如果是空的则遍历结束），输出该元素，然后如果该元素有右节点则将cur指针跳到该右节点。 关键在于还是要理解计算机递归的实现原理，然后用程序去加以模拟和实现。例如这题，就可以参考中序遍历二叉树的递归版本，在脑海中模拟一下整个递归过程，即子调用的进入和退出的顺序，就能知道应该用一个栈去模拟这个过程，并且何时入栈和何时出栈。 代码 class Solution: # @param root, a tree node # @return a list of integers def inorderTraversal(self, root): if None == root: return [ ] list = [ ] stack = [ ] cur = root stack.append(cur) while True: if None != cur and None != cur.left: stack.append(cur.left) cur = cur.left continue if len(stack) >= 1: cur = stack.pop() list.append(cur.val) cur = cur.right else: break if None != cur: stack.append(cur) return list Welcome to my blob Xnerv Surveys "},"unique-binary-search-trees/":{"url":"unique-binary-search-trees/","title":"96. Unique Binary Search Trees","keywords":"","body":"【LeetCode with Python】 96. Unique Binary Search Trees题目分析代码【LeetCode with Python】 96. Unique Binary Search Trees tagsstart Medium Problems Tree Dynamic Programming tagsstop 题目 原题页面：https://leetcode.com/problems/unique-binary-search-trees/ 本文地址：http://leetcode.xnerv.wang/unique-binary-search-trees/ 题目类型：Tree, Dynamic Programming 难度评价：Medium 类似题目：(M) Unique Binary Search Trees II Given n, how many structurally unique BST's (binary search trees) that store values 1...n? For example, Given n = 3, there are a total of 5 unique BST's. 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 分析 给点节点数，求出能构造出符合二叉搜索树定义的二叉树数量。 搜索算法。用递归来构建搜索，每次递归时，假设当前子树可分配节点数为n，那就列举每一种分配方案（子树根节点占用一个，第一种方案是左子树分配0个节点，右子树分配n-1个结点；第二种方案左子树分配1个节点，右子树分配n-2个节点；……；最后左子树分配n-1个节点，右子树分配0个节点）并继续子递归。最后累加各个分配方案可以得到的二叉树数量，作为本次递归结果返回。 空间复杂度与时间复杂度待分析。 搜索算法一般都可以通过动态规划DP来避免重复的子问题求解，以后有时间了会用DP重新做一次本题。 代码 class Solution: def doNumTrees(self, n): if n Welcome to my blob Xnerv Surveys "},"interleaving-string/":{"url":"interleaving-string/","title":"97. Interleaving String","keywords":"","body":"【LeetCode with Python】 97. Interleaving String题目分析代码【LeetCode with Python】 97. Interleaving String tagsstart Hard Problems Dynamic Programming String tagsstop 题目 原题页面：https://leetcode.com/problems/interleaving-string/ 本文地址：http://leetcode.xnerv.wang/interleaving-string/ 题目类型：Dynamic Programming, String 难度评价：Hard Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example, Given: s1 = \"aabcc\", s2 = \"dbbca\", When s3 = \"aadbbcbcac\", return true. When s3 = \"aadbbbaccc\", return false. 分析 比较常规的一道字符串DP问题。注意检查传入参数，可以加速某些极端case的检测速度。此外还可以用两个row代替一个完整的二维矩阵，节约空间消耗。 代码 class Solution: # @return a boolean def isInterleave(self, s1, s2, s3): len1 = len(s1) len2 = len(s2) len3 = len(s3) if len1 + len2 != len3: return False if 0 == len1: return s2 == s3 if 0 == len2: return s1 == s3 row1 = [False for col in range(len2 + 1)] row1[0] = True for i in range(1, len2 + 1): row1[i] = ( row1[i - 1] and (s2[i - 1] == s3[i - 1])) row2 = [False for col in range(len2 + 1)] for m in range(1, len1 + 1): row2[0] = (row1[0] and (s1[m - 1] == s3[m - 1])) for n in range(1, len2 + 1): k = m + n - 1 # why and ? because [m, n] maybe come from up or left, one of the two is the right source. row2[n] = (s1[m - 1] == s3[k] and row1[n]) or (s2[n - 1] == s3[k] and row2[n - 1]) row1, row2 = row2, row1 return row1[len2] Welcome to my blob Xnerv Surveys "},"validate-binary-search-tree/":{"url":"validate-binary-search-tree/","title":"98. Validate Binary Search Tree","keywords":"","body":"【LeetCode with Python】 98. Validate Binary Search Tree题目分析代码【LeetCode with Python】 98. Validate Binary Search Tree tagsstart Medium Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/validate-binary-search-tree/ 本文地址：http://leetcode.xnerv.wang/validate-binary-search-tree/ 题目类型：Medium 难度评价：Tree, Depth-first Search 类似题目：(M) Binary Tree Inorder Traversal Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. confused what \"{1,#,2,3}\" means? OJ's Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". 分析 检查一颗二叉树是不是有效的二叉搜索树BST。注意BST的定义，不仅仅左孩子结点的值比当前结点小，左子树上所有结点的值都要比当前结点小（BST跟heap是不同，heap只要求每个节点的直接左节点比直接右节点小即可）。右子树上所有结点的值则都要比当前结点大。使用递归检查每一棵子树是不是BST，然后回溯的时候将检查结果，以及当前子树的最大和最小结点值返回给上一层递归。注意Python的return是可以返回一个元组的，相当于可以同时return多个变量，非常方便。 代码 class Solution: def recurIsValidBST(self, root): if None == root: return True, None, None elif None == root.left and None == root.right: return True, root.val, root.val else: left_bool, left_min, left_max = self.recurIsValidBST(root.left) right_bool, right_min, right_max = self.recurIsValidBST(root.right) cur_bool = left_bool and right_bool and (None == left_max or root.val > left_max) and (None == right_min or root.val Welcome to my blob Xnerv Surveys "},"same-tree/":{"url":"same-tree/","title":"100. Same Tree","keywords":"","body":"【LeetCode with Python】 100. Same Tree题目分析代码【LeetCode with Python】 100. Same Tree tagsstart Easy Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/same-tree/ 本文地址：http://leetcode.xnerv.wang/same-tree/ 题目类型：Easy 难度评价：Tree, Depth-first Search Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 分析 判断两个二叉树是否相等。常见的二叉树递归回溯算法。 代码 class Solution: # @param p, a tree node # @param q, a tree node # @return a boolean def isSameTree(self, p, q): if None == p and None == q: return True elif (None == p and None != q) or (None != p and None == q): return False else: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) Welcome to my blob Xnerv Surveys "},"symmetric-tree/":{"url":"symmetric-tree/","title":"101. Symmetric Tree","keywords":"","body":"【LeetCode with Python】 101. Symmetric Tree题目分析代码【LeetCode with Python】 101. Symmetric Tree tagsstart Easy Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/symmetric-tree/ 本文地址：http://leetcode.xnerv.wang/symmetric-tree/ 题目类型：Tree, Depth-first Search 难度评价：Easy Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following is not: 1 / \\ 2 2 \\ \\ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. confused what \"{1,#,2,3}\" means? OJ's Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". 分析 最开始想到的方法是进行二叉树的层次遍历，判断每一层的节点列表是不是左右对称的。但题目建议用递归回溯，但是如何在递归中判断对称的确不容易想到。 就这道题目而言，其实也是递归地判断每组对称的两点是否相等。 代码 class Solution: def checkSysmmetric(self, left, right): if None == left and None == right: return True elif None == left or None == right: return False elif left.val != right.val: return False return self.checkSysmmetric(left.left, right.right) and self.checkSysmmetric(left.right, right.left) # @param root, a tree node # @return a boolean def isSymmetric(self, root): if None == root: return True return self.checkSysmmetric(root.left, root.right) Welcome to my blob Xnerv Surveys "},"binary-tree-level-order-traversal/":{"url":"binary-tree-level-order-traversal/","title":"102. Binary Tree Level Order Traversal","keywords":"","body":"【LeetCode with Python】 102. Binary Tree Level Order Traversal题目分析代码【LeetCode with Python】 102. Binary Tree Level Order Traversal tagsstart Easy Problems Tree Breadth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ 本文地址：http://leetcode.xnerv.wang/binary-tree-level-order-traversal/ 题目类型：Tree, Breadth-first Search 难度评价：Easy 类似题目：(M) Binary Tree Zigzag Level Order Traversal, (E) Binary Tree Level Order Traversal II, (E) Minimum Depth of Binary Tree Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] confused what \"{1,#,2,3}\" means? OJ's Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". 分析 二叉树的层次遍历应用在LeetCode中出现了好几次。一般而言二叉树层次遍历是用队列，但是由于本题要区分出每一层，因此用两个数组分别模拟队列。 代码 class Solution: # @param root, a tree node # @return a list of lists of integers def levelOrder(self, root): if None == root: return [ ] results = [ [root.val] ] reflist1 = [root] while True: reflist2 = [ ] result = [ ] for i in range(0, len(reflist1)): cur = reflist1[i] if None != cur.left: reflist2.append(cur.left) result.append(cur.left.val) if None != cur.right: reflist2.append(cur.right) result.append(cur.right.val) if 0 == len(reflist2): break results.append(result) reflist1 = reflist2 return results Welcome to my blob Xnerv Surveys "},"maximum-depth-of-binary-tree/":{"url":"maximum-depth-of-binary-tree/","title":"104. Maximum Depth of Binary Tree","keywords":"","body":"【LeetCode with Python】 104. Maximum Depth of Binary Tree题目分析代码【LeetCode with Python】 104. Maximum Depth of Binary Tree tagsstart Easy Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/maximum-depth-of-binary-tree/ 本文地址：http://leetcode.xnerv.wang/maximum-depth-of-binary-tree/ 题目类型：Tree, Depth-first Search 难度评价：Easy 类似题目：(E) Balanced Binary Tree, (E) Minimum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 分析 计算二叉树的最大深度，正规的递归回溯解法。 代码 class Solution: def recurMaxDepth(self, root, depth): if None == root: return 0 elif None == root.left and None == root.right: return 1 left_depth = (self.recurMaxDepth(root.left, depth) if None != root.left else 0) right_depth = (self.recurMaxDepth(root.right, depth) if None != root.right else 0) # warn: a node just have a child, a node have two child, their height calculation method are different. if left_depth > 0 and right_depth > 0: return max(left_depth, right_depth) + 1; elif left_depth > 0: return left_depth + 1 else: # right_depth > 0, or (left_depth == 0 and right_depth == 0) return right_depth + 1 # @param root, a tree node # @return an integer def maxDepth(self, root): return self.recurMaxDepth(root, 0) Welcome to my blob Xnerv Surveys "},"binary-tree-level-order-traversal-ii/":{"url":"binary-tree-level-order-traversal-ii/","title":"107. Binary Tree Level Order Traversal II","keywords":"","body":"【LeetCode with Python】 107. Binary Tree Level Order Traversal II题目分析代码【LeetCode with Python】 107. Binary Tree Level Order Traversal II tagsstart Easy Problems Tree Breadth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ 本文地址：http://leetcode.xnerv.wang/binary-tree-level-order-traversal-ii/ 题目类型：Tree, Breadth-first Search 难度评价：Easy 类似题目：(E) Binary Tree Level Order Traversal Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] confused what \"{1,#,2,3}\" means? OJ's Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\". 分析 不知道出题意图是不是希望用递归，从叶子节点到根结点，将每一个节点加入到结果二维数组的相应层次中？ 不过我这里就追求简单，直接将Binary Tree Level Order Traversal的结果数组reverse一下。。。 代码 class Solution: # @param root, a tree node # @return a list of lists of integers def levelOrder(self, root): if None == root: return [ ] results = [ [root.val] ] reflist1 = [root] while True: reflist2 = [ ] result = [ ] for i in range(0, len(reflist1)): cur = reflist1[i] if None != cur.left: reflist2.append(cur.left) result.append(cur.left.val) if None != cur.right: reflist2.append(cur.right) result.append(cur.right.val) if 0 == len(reflist2): break results.append(result) reflist1 = reflist2 return results def levelOrderBottom(self, root): results = self.levelOrder(root) results.reverse() return results Welcome to my blob Xnerv Surveys "},"convert-sorted-array-to-binary-search-tree/":{"url":"convert-sorted-array-to-binary-search-tree/","title":"108. Convert Sorted Array to Binary Search Tree","keywords":"","body":"【LeetCode with Python】 108. Convert Sorted Array to Binary Search Tree题目分析代码【LeetCode with Python】 108. Convert Sorted Array to Binary Search Tree tagsstart Medium Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ 本文地址：http://leetcode.xnerv.wang/convert-sorted-array-to-binary-search-tree/ 题目类型：Tree, Depth-first Search 难度评价：Medium 类似题目：(M) Convert Sorted List to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 分析 用递归的方法，每次选择当前子序列的中点作为子树的root，然后再递归对左边子序列和右边子序列进行处理。 原题中标注为深度搜索DFS。这里是构建二叉树，构建的顺序类似于二叉树的先序遍历。由于树是一种特殊的图，因此二叉树的先序遍历其实就是图的DFS，而层次遍历就是图的BFS。 代码 class Solution: def doSortedArrayToBST(self, num, start, end): if start > end: return None mid = start + (end - start) / 2 root = TreeNode(num[mid]) root.left = self.doSortedArrayToBST(num, start, mid - 1) root.right = self.doSortedArrayToBST(num, mid + 1, end) return root # @param num, a list of integers # @return a tree node def sortedArrayToBST(self, num): len_num = len(num) if 0 == len_num: return None return self.doSortedArrayToBST(num, 0, len_num - 1) Welcome to my blob Xnerv Surveys "},"balanced-binary-tree/":{"url":"balanced-binary-tree/","title":"110. Balanced Binary Tree","keywords":"","body":"【LeetCode with Python】 110. Balanced Binary Tree题目分析代码【LeetCode with Python】 110. Balanced Binary Tree tagsstart Easy Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/balanced-binary-tree/ 本文地址：http://leetcode.xnerv.wang/balanced-binary-tree/ 题目类型：Tree, Depth-first Search 难度评价：Easy 类似题目：(E) Maximum Depth of Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 分析 判断一棵树是否高度平衡，即每个节点的左右子树高度相差不过1，参考BBT二叉平衡树或AVL的定义。还是用常见的二叉树递归回溯解法。 代码 class Solution: def checkBBT(self, root): if None == root: return True, 0 isLeftBBT, leftDepth = self.checkBBT(root.left) isRightBBT, rightDepth = self.checkBBT(root.right) isBBT = isLeftBBT and isRightBBT and abs(leftDepth - rightDepth) Welcome to my blob Xnerv Surveys "},"minimum-depth-of-binary-tree/":{"url":"minimum-depth-of-binary-tree/","title":"111. Minimum Depth of Binary Tree","keywords":"","body":"【LeetCode with Python】 111. Minimum Depth of Binary Tree题目分析代码【LeetCode with Python】 111. Minimum Depth of Binary Tree tagsstart Easy Problems Tree Depth-first Search Breadth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/minimum-depth-of-binary-tree/ 本文地址：http://leetcode.xnerv.wang/minimum-depth-of-binary-tree/ 题目类型：Tree, Depth-first Search, Breadth-first Search 难度评价：Easy 类似题目：(E) Binary Tree Level Order Traversal, (E) Meeting Rooms, (E) Maximum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 分析 计算二叉树的最小深度。好像还有另外一道题是计算二叉树的最大深度，其实解法都类似，递归加回溯。 但是要注意一点的是，如果一个node的左子树高度是2，右子树高度是0，则说明node是没有右节点的，此时node为root的子树的最小高度应该是2+1=3，而不应该是0+1=2。 代码 class Solution: def recurMinDepth(self, root, depth): if None == root: return 0 elif None == root.left and None == root.right: return 1 left_depth = (self.recurMinDepth(root.left, depth) if None != root.left else 0) right_depth = (self.recurMinDepth(root.right, depth) if None != root.right else 0) # warn: a node just have a child, a node have two child, their height calculation method are different. if left_depth > 0 and right_depth > 0: return min(left_depth, right_depth) + 1; elif left_depth > 0: return left_depth + 1 else: # right_depth > 0, or (left_depth == 0 and right_depth == 0) return right_depth + 1 # @param root, a tree node # @return an integer def minDepth(self, root): return self.recurMinDepth(root, 0) Welcome to my blob Xnerv Surveys "},"path-sum/":{"url":"path-sum/","title":"112. Path Sum","keywords":"","body":"【LeetCode with Python】 112. Path Sum题目分析代码【LeetCode with Python】 112. Path Sum tagsstart Easy Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/path-sum/ 本文地址：http://leetcode.xnerv.wang/path-sum/ 题目类型：Tree, Depth-first Search 难度评价：Easy 类似题目：(M) Path Sum II, (H) Binary Tree Maximum Path Sum, (M) Sum Root to Leaf Numbers Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. 分析 简单的递归算法。但是注意一点，当树为空树时，无论sum是多少都一定要返回False，即使此时sum为0。另外因为只要确定有解即可，因此如果某次迭代发现left已经找到解，那么就不需要再去右子树中寻找解。 但是，因为可能有负数出现，所以不能因为path sum已经大于指定sum值就认为该分支可以被剪除。 代码 class Solution: def doHasPathSum(self, root, total, sum): if None == root.left and None == root.right: return sum == (total + root.val) left= False right = False if None != root.left: left = self.doHasPathSum(root.left, total + root.val, sum) if False != left and None != root.right: # pruning right = self.doHasPathSum(root.right, total + root.val, sum) return left or right # @param root, a tree node # @param sum, an integer # @return a boolean def hasPathSum(self, root, sum): if None == root: return False ### return self.doHasPathSum(root, 0, sum) Welcome to my blob Xnerv Surveys "},"path-sum-ii/":{"url":"path-sum-ii/","title":"113. Path Sum II","keywords":"","body":"【LeetCode with Python】 113. Path Sum II题目分析代码【LeetCode with Python】 113. Path Sum II tagsstart Medium Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/path-sum-ii/ 本文地址：http://leetcode.xnerv.wang/path-sum-ii/ 题目类型：Tree, Depth-first Search 难度评价：Medium 类似题目：(E) Path Sum, (E) Binary Tree Paths Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 return [ [5,4,11,2], [5,8,4,5] ] 分析 和Path Sum差不多，不过要记录一下所有可行解。 代码 class Solution: def __init__(self): self.paths = [ ] def doPathSum(self, root, total, sum, path): if None == root.left and None == root.right: path.append(root.val) result = (sum == (total + root.val)) if True == result: self.paths.append(path) left= False right = False if None != root.left: new_path = path[:] new_path.append(root.val) left = self.doPathSum(root.left, total + root.val, sum, new_path) if None != root.right: new_path = path[:] new_path.append(root.val) right = self.doPathSum(root.right, total + root.val, sum, new_path) return left or right # @param root, a tree node # @param sum, an integer # @return a list of lists of integers def pathSum(self, root, sum): if None == root: return [ ] ### result = self.doPathSum(root, 0, sum, [ ]) return self.paths Welcome to my blob Xnerv Surveys "},"flatten-binary-tree-to-linked-list/":{"url":"flatten-binary-tree-to-linked-list/","title":"114. Flatten Binary Tree to Linked List","keywords":"","body":"【LeetCode with Python】 114. Flatten Binary Tree to Linked List题目分析代码【LeetCode with Python】 114. Flatten Binary Tree to Linked List tagsstart Medium Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ 本文地址：http://leetcode.xnerv.wang/flatten-binary-tree-to-linked-list/ 题目类型：Tree, Depth-first Search 难度评价：Medium Given a binary tree, flatten it to a linked list in-place. For example, Given 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 Hints: If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal. 分析 题目的算法本身并不难理解，按照先序遍历的节点顺序将一棵二叉树拉平为一个“链表”。因此后序遍历二叉树，先将左子树“拉平”，再将右子树“拉平”，然后如果左子树不是None，就将已经拉平为“链表”的左子树，嵌入到当前节点与直接右孩子节点（可能右孩子是None）之间。关键在于一些分支上要判断是否不为None，很容易出错。 代码 class Solution: # @param root, a tree node # @return nothing, do it in place def flatten(self, root): if None == root: return if None != root.left: self.flatten(root.left) if None != root.right: self.flatten(root.right) left = root.left right = root.left while None != right and None != right.right: right = right.right if None != right: right.right = root.right if None != left: ### root.right = left root.left = None Welcome to my blob Xnerv Surveys "},"populating-next-right-pointers-in-each-node/":{"url":"populating-next-right-pointers-in-each-node/","title":"116. Populating Next Right Pointers in Each Node","keywords":"","body":"【LeetCode with Python】 116. Populating Next Right Pointers in Each Node题目分析代码【LeetCode with Python】 116. Populating Next Right Pointers in Each Node tagsstart Medium Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ 本文地址：http://leetcode.xnerv.wang/populating-next-right-pointers-in-each-node/ 题目类型：Tree, Depth-first SearchTwo Pointers 难度评价：Medium 类似题目：(H) Populating Next Right Pointers in Each II Node, (M) Binary Tree Right Side View Given a binary tree struct TreeLinkNode { TreeLinkNode left; TreeLinkNode right; TreeLinkNode next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. *Note: You may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). For example, Given the following perfect binary tree, 1 / \\ 2 3 / \\ / \\ 4 5 6 7 After calling your function, the tree should look like: 1 -> NULL / \\ 2 -> 3 -> NULL / \\ / \\ 4->5->6->7 -> NULL 分析 类似于层次遍历的方法，参考Binary Tree Level Order Traversal这道题的代码，其实就是在其基础上加上了对一层结点的next指针的处理逻辑。 此外，这道题的衍生版本Populating Next Right Pointers in Each Node II与本题的区别是，本题是完全二叉树，而Populating Next Right Pointers in Each Node II却可能是任意结构的二叉树。但本题的代码对于这两道题都可以通过。 （但是本题代码可能不符合题意要求，题目要求消耗常量空间） 代码 # Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = None class Solution: # @param root, a tree node # @return nothing def connect(self, root): if None == root: return [ ] reflist1 = [root] while True: reflist2 = [ ] for i in range(0, len(reflist1)): cur = reflist1[i] if None != cur.left: reflist2.append(cur.left) if None != cur.right: reflist2.append(cur.right) if 0 == len(reflist2): break len_l = len(reflist2) for i in range(0, len_l - 1): reflist2[i].next = reflist2[i + 1] reflist2[len_l - 1].next = None reflist1 = reflist2 Welcome to my blob Xnerv Surveys "},"populating-next-right-pointers-in-each-node-ii/":{"url":"populating-next-right-pointers-in-each-node-ii/","title":"117. Populating Next Right Pointers in Each Node II","keywords":"","body":"【LeetCode with Python】 117. Populating Next Right Pointers in Each Node II题目分析代码【LeetCode with Python】 117. Populating Next Right Pointers in Each Node II tagsstart Hard Problems Tree Depth-first Search todo tagsstop 题目 原题页面：https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ 本文地址：http://leetcode.xnerv.wang/populating-next-right-pointers-in-each-node-ii/ 题目类型：Tree, Depth-first SearchTwo Pointers 难度评价：Hard 类似题目：(M) Populating Next Right Pointers in Each Node Follow up for problem \"Populating Next Right Pointers in Each Node\". What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space. For example, Given the following binary tree, 1 / \\ 2 3 / \\ \\ 4 5 7 After calling your function, the tree should look like: 1 -> NULL / \\ 2 -> 3 -> NULL / \\ \\ 4-> 5 -> 7 -> NULL 分析 复用Populating Next Right Pointers in Each Node的代码直接可以通过。 （但是本题代码可能不符合题意要求，题目要求消耗常量空间） 代码 # Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = None class Solution: # @param root, a tree node # @return nothing def connect(self, root): if None == root: return [ ] reflist1 = [root] while True: reflist2 = [ ] for i in range(0, len(reflist1)): cur = reflist1[i] if None != cur.left: reflist2.append(cur.left) if None != cur.right: reflist2.append(cur.right) if 0 == len(reflist2): break len_l = len(reflist2) for i in range(0, len_l - 1): reflist2[i].next = reflist2[i + 1] reflist2[len_l - 1].next = None reflist1 = reflist2 Welcome to my blob Xnerv Surveys "},"pascal's-triangle/":{"url":"pascal's-triangle/","title":"118. Pascal's Triangle","keywords":"","body":"【LeetCode with Python】 118. Pascal's Triangle题目分析代码【LeetCode with Python】 118. Pascal's Triangle tagsstart Easy Problems Array tagsstop 题目 原题页面：https://leetcode.com/problems/pascals-triangle/ 本文地址：http://leetcode.xnerv.wang/pascals-triangle/ 题目类型：Array 难度评价：Easy 类似题目：(E) Pascal's Triangle II Given numRows, generate the first numRows of Pascal's triangle. For example, given numRows = 5, Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 分析 输出帕斯卡三角，明白帕斯卡三角的定义即可简单解题。 代码 class Solution: # @return a list of lists of integers def generate(self, numRows): rows = [] if numRows = 1: rows.append([1]) if numRows >= 2: rows.append([1, 1]) if numRows >= 3: need_rowsnum = numRows - 2 last_row = [1, 1] for i in range(0, need_rowsnum): new_row = [1] for j in range(1, len(last_row)): new_row.append(last_row[j - 1] + last_row[j]) new_row.append(1) rows.append(new_row) last_row = new_row return rows Welcome to my blob Xnerv Surveys "},"pascal's-triangle-ii/":{"url":"pascal's-triangle-ii/","title":"119. Pascal's Triangle II","keywords":"","body":"【LeetCode with Python】 119. Pascal's Triangle II题目分析代码【LeetCode with Python】 119. Pascal's Triangle II tagsstart Easy Problems Array tagsstop 题目 原题页面：https://leetcode.com/problems/pascals-triangle-ii/ 本文地址：http://leetcode.xnerv.wang/pascals-triangle-ii/ 题目类型：Array 难度评价：Easy 类似题目：(E) Pascal's Triangle Given an index k, return the kth row of the Pascal's triangle. For example, given k = 3, Return [1,3,3,1]. Note: Could you optimize your algorithm to use only O(k) extra space? 分析 和Pascal's Triangle类似的题目，不过要求的不是输出整个帕斯卡三角，而是输出其中的某一层了。 代码 class Solution: # @return a list of lists of integers def getRow(self, rowIndex): if rowIndex = 2: need_rowsnum = rowIndex - 1 last_row = [1, 1] for i in range(0, need_rowsnum): new_row = [1] for j in range(1, len(last_row)): new_row.append(last_row[j - 1] + last_row[j]) new_row.append(1) last_row = new_row return last_row Welcome to my blob Xnerv Surveys "},"best-time-to-buy-and-sell-stock/":{"url":"best-time-to-buy-and-sell-stock/","title":"121. Best Time to Buy and Sell Stock","keywords":"","body":"【LeetCode with Python】 121. Best Time to Buy and Sell Stock题目分析代码【LeetCode with Python】 121. Best Time to Buy and Sell Stock tagsstart Medium Problems Array Dynamic Programming tagsstop 题目 原题页面：https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ 本文地址：http://leetcode.xnerv.wang/best-time-to-buy-and-sell-stock/ 题目类型：Array Dynamic Programming 难度评价：Medium Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 分析 因为只允许完成一笔交易，因此只要遍历一次数组，找出最大的差值即可，不过必须是最大值出现在最小值的右边，所以不能简单地遍历数组找出最大值和最小值相减，因此这样可能造成的是“最大亏损”。正确的做法是：遍历一次数组，每遍历到一个元素时，都记录历史上出现过的最小值，然后计算当前遍历到的元素与历史最小值的差值，再记录历史上该差值的最大值即可。 据原题说明这属于动态规划题目，也许是所谓的一维动态规划？本人对动态规划的定义一直是不得要领……或许可以这样认为，凡是类似于数据归纳法这样，可以把问题分解为一个逐步的基于子问题的求解过程，就是动态规划。而子问题可以从几个维度分解，就是几维的动态规划。例如这里是从天数这一个维度上可以分解，就是一维动态规划。01背包问题，可以从背包容量和物品两个维度上划分，就是二维动态规划。 代码 class Solution: # @param prices, a list of integer # @return an integer def maxProfit(self, prices): if None == prices or len(prices) max_diff: max_diff = cur_diff return max_diff Welcome to my blob Xnerv Surveys "},"best-time-to-buy-and-sell-stock-ii/":{"url":"best-time-to-buy-and-sell-stock-ii/","title":"122. Best Time to Buy and Sell Stock II","keywords":"","body":"【LeetCode with Python】 122. Best Time to Buy and Sell Stock II题目分析代码【LeetCode with Python】 122. Best Time to Buy and Sell Stock II tagsstart Medium Problems Array Greedy tagsstop 题目 原题页面：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ 本文地址：http://leetcode.xnerv.wang/best-time-to-buy-and-sell-stock-ii/ 题目类型：Array, Greedy 难度评价：Medium 类似题目：(M) Best Time to Buy and Sell Stock, (H) Best Time to Buy and Sell Stock III, (H) Best Time to Buy and Sell Stock IV Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 分析 一开始还以为是找出序列中的最大值和最小值然后求差，这种错误的想法充分暴露了本人炒股属于把钱往里一丢就再也不管了的类型。其实这题体现的就是一个“低买高买”的贪婪思想，需要找到每一个递增的子序列，从而使利润最大化。 代码 class Solution: # @param prices, a list of integer # @return an integer def maxProfit(self, prices): len_prices = len(prices) if len_prices = prices[index - 1]: income = cur - start index += 1 if len_prices == index: total_income += income else: total_income += income income = 0 start = cur index += 1 return total_income Welcome to my blob Xnerv Surveys "},"binary-tree-maximum-path-sum/":{"url":"binary-tree-maximum-path-sum/","title":"124. Binary Tree Maximum Path Sum","keywords":"","body":"【LeetCode with Python】 124. Binary Tree Maximum Path Sum题目分析代码【LeetCode with Python】 124. Binary Tree Maximum Path Sum tagsstart Hard Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/binary-tree-maximum-path-sum/ 本文地址：http://leetcode.xnerv.wang/binary-tree-maximum-path-sum/ 题目类型：Tree, Depth-first Search 难度评价：Hard 类似题目：(M) Path Sum, (M) Sum Root to Leaf Numbers Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root. For example: Given the below binary tree, 1 / \\ 2 3 Return 6. 分析 本是比较简单的一道二叉树递归算法题目，也花了一些时间。主要还是在题意的理解中，本题要求的“最大路径和”，不一定经过了root，起点和终点可以是同一个点（即整个路径只有一个点）。 注意用一个类成员变量max来记录搜索过程中出现过的最大路径和，最后需要返回的就是这个max值。 此外还有一点容易搞错，当一棵子树计算完退栈时，向上一层返回的应该是该子树左路径、右路径中的最大值，而不是该子树中的“最大路径和”，因为从父节点搜索进入该子树时，只能选择其左分支或者右分治进入。 最后需要注意的一点是，这道题目并没有说节点的值是正数或者自然数，考虑到leetcode一贯的尿性，最好认为负数也是会出现的。 代码 class Solution: def __init__(self): self.max = None def doMaxPathSum(self, root): if None == root: return 0 left_sum = self.doMaxPathSum(root.left) right_sum = self.doMaxPathSum(root.right) max_left_sum = max(left_sum, 0) max_right_sum = max(right_sum, 0) cur_max = max_left_sum + max_right_sum + root.val if None == self.max or cur_max > self.max: self.max = cur_max return max(max_left_sum + root.val, max_right_sum + root.val) # @param root, a tree node # @return an integer def maxPathSum(self, root): self.doMaxPathSum(root) return self.max Welcome to my blob Xnerv Surveys "},"valid-palindrome/":{"url":"valid-palindrome/","title":"125. Valid Palindrome","keywords":"","body":"【LeetCode with Python】 125. Valid Palindrome题目分析代码【LeetCode with Python】 125. Valid Palindrome tagsstart Easy Problems Two Pointers String tagsstop 题目 原题页面：https://leetcode.com/problems/valid-palindrome/ 本文地址：http://leetcode.xnerv.wang/valid-palindrome/ 题目类型：Two Pointers, String 难度评价：Easy 类似题目：(E) Palindrome Linked List Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, \"A man, a plan, a canal: Panama\" is a palindrome. \"race a car\" is not a palindrome. Note: Have you consider that the string might be empty? This is a good question to > ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. 分析 判断一个字符串是否为回文，忽略字母和数字外的字符，忽略字母大小写，并且注意检测作为参数传入的字符串是否为空串。这可能就是面试时的编程题与ACM赛题的最大区别之一：需要考虑各种异常情形和边界条件，题目虽简单，面试官考察的是应试者整体的编程思维，而不仅仅是具体某个精妙的算法。 代码 class Solution: # @param s, a string # @return a boolean def isPalindrome(self, s): len_s = len(s) if len_s = 'a' and s[left_idx] = 'A' and s[left_idx] = '0' and s[left_idx] = 'A' and s[left_idx] = 'a' and s[right_idx] = 'A' and s[right_idx] = '0' and s[right_idx] = 'A' and s[right_idx] Welcome to my blob Xnerv Surveys "},"longest-consecutive-sequence/":{"url":"longest-consecutive-sequence/","title":"128. Longest Consecutive Sequence","keywords":"","body":"【LeetCode with Python】 128. Longest Consecutive Sequence题目分析代码【LeetCode with Python】 128. Longest Consecutive Sequence tagsstart Hard Problems Array tagsstop 题目 原题页面：https://leetcode.com/problems/longest-consecutive-sequence/ 本文地址：http://leetcode.xnerv.wang/longest-consecutive-sequence/ 题目类型：Array 难度评价：Hard Given an unsorted array of integers, find the length of the longest consecutive elements sequence. For example, Given [100, 4, 200, 1, 3, 2], The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. Your algorithm should run in O(n) complexity. 分析 给定一个不一定有序的int序列，从里面找出一些能够构成一个新序列的数字，要求这些数字是连续的，并且新序列能足够长。 先对原序列排序，然后再遍历一次找最长连续序列这种做法是最直观的，时间复杂度是O(nlogn)+O(n)=O(nlog(n))，显然不满足本题要求O(n)复杂度的要求（话说原题要求的这个O(n)复杂度是仅指时间复杂度，还是同时要求时间复杂度和空间复杂度？估计是后者）。所以用一个hashmap，首先遍历原序列，以每个元素值作为key，True作为value插入到hashmap中。然后就可以遍历这个hashmap中的每个元素，试图去搜索这个元素左右连续的元素是否存在于hashmap中，从而去找出最长的连续序列。同时注意将搜索过的元素的Value置为False，避免对已经搜索过的连续序列中的元素再重复搜索。 空间复杂度O(n)。时间复杂度O(n)。由于Python中的字典就是用hash表实现的，因此这里就暂用字典代替hash表。 注意避免重复搜索同一连续序列中的其它元素。 总的来说这种算法比较难想到，排序后再遍历的算法比较直观，可能会在第一时间想到。 代码 class Solution: # @param num, a list of integer # @return an integer def longestConsecutive(self, num): hashmap = { } for i in num: hashmap[i] = True max_n = 0 for k, v in hashmap.items(): if not v: continue left = k - 1 right = k + 1 while hashmap.has_key(left) and hashmap[left]: hashmap[left] = False left -= 1 while hashmap.has_key(right) and hashmap[right]: hashmap[right] = False right += 1 n = right - left - 1 if n > max_n: max_n = n return max_n Welcome to my blob Xnerv Surveys "},"sum-root-to-leaf-numbers/":{"url":"sum-root-to-leaf-numbers/","title":"129. Sum Root to Leaf Numbers","keywords":"","body":"【LeetCode with Python】 129. Sum Root to Leaf Numbers题目分析代码【LeetCode with Python】 129. Sum Root to Leaf Numbers tagsstart Medium Problems Tree Depth-first Search tagsstop 题目 原题页面：https://leetcode.com/problems/sum-root-to-leaf-numbers/ 本文地址：http://leetcode.xnerv.wang/sum-root-to-leaf-numbers/ 题目类型：Tree, Depth-first Search 难度评价：Medium 类似题目：(E) Path Sum, (H) Binary Tree Maximum Path Sum Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. For example, 1 / \\ 2 3 The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Return the sum = 12 + 13 = 25. 分析 从根节点到叶子节点的路径代表一个数值，找出所有的这些数值然后累加得到一个和。 搜索算法可以用来找可行解，或者找出全部解。找可行解的时候可以用深度优先遍历DFS，或者广度优先遍历BFS。而这个题目则是找出全部解，然后累加全部解。而搜索算法找全部解时的递归解法一般也是两种：自底向上和自顶向下（自己命名的，哈哈）。 就拿这道题来说，自底向上，也就是当递归到叶子节点后，在递归退栈的过程中，让左子树递归返回的数加上右子树递归返回的数。 注意解法中其实用到了乘法分配律，否则每次“归”的时候，就得向上层返回一个数的列表，且越接近root的时候列表会越长。或者记录一个对象内的成员变量，当遍历到叶子节点时，每个叶子节点将到达自身所形成的路径的值加上到成员变量上。 代码 class Solution: def doSumNumbers(self, root, val): if None == root.left and None == root.right: return val * 10 + root.val left = 0 right = 0 if None != root.left: left = self.doSumNumbers(root.left, val * 10 + root.val) if None != root.right: right = self.doSumNumbers(root.right, val * 10 + root.val) return left + right # @param root, a tree node # @return an integer def sumNumbers(self, root): if None == root: return 0 return self.doSumNumbers(root, 0) Welcome to my blob Xnerv Surveys "},"gas-station/":{"url":"gas-station/","title":"134. Gas Station","keywords":"","body":"【LeetCode with Python】 134. Gas Station题目分析代码【LeetCode with Python】 134. Gas Station tagsstart Medium Problems Greedy tagsstop 题目 原题页面：https://leetcode.com/problems/gas-station/ 本文地址：http://leetcode.xnerv.wang/gas-station/ 题目类型：Greedy 难度评价：Medium There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once, otherwise return -1. Note: The solution is guaranteed to be unique. 分析 基本解题思路是：先计算出一个“结余”数组，即当前车辆剩余油量，加上每一站可以补充的油量，减去从该站出发到下一站的消耗量，即每一站的“结余量”。一条合法的路线，当车辆处于中间的每一个点上，“结余量”都不能小于0。 不过有两种方法可以减小计算量，使得时间复杂度为O(n)，而不是暴力搜索时的O(n*n)。 一是假设当从A点出发，到D点时如果结余量小于0，则下一次的起点直接设置为D（其实应该可以设置为D的下一点E，这里为了程序逻辑处理简单就设为了D）。理由如下：A到C的累加和都>=0，而D应该是一个绝对值比这个累加和都大的负数，因此导致D点的结余量为负。 如果这时不把新的起点设置为D，而是设置为B，毫无疑问A>=0（否则在A点时就结余量为负了），既然A+B+C的结余量都不够D点消耗，则B+C更加不够D点消耗了。 如果此时新的起点设置为C，首先毫无疑问A+B>=0，否则A+B的结余量就不够C点消耗。既然A+B+C的结余量都不够D点消耗，则C点的结余量就更不够D点消耗了。 …… 这可以看作：一条合法（或局部合法）的线路，其前缀之和总是一个非负数。如果当前点没有足够结余量可以通过，那去除任意长度的一个前缀，将更加不可能通过。 二是可以保存前缀之和中的最小值。因为题中线路是一个环形，而程序中是一个线性数组。当从数组中的某一点出发，到达数组尾部后，又要绕回数组头部，直到回到出发点。从一中已经可以保证尾部任何一个元素不会被重复在两次累加计算中出现，那么头部应该也可以这样避免被重复计算。用一个变量保存头部前缀的累加计算过程中出现过的最小和，则在某次累加计算过程中，只要尾部元素的总和结余量仍足够头部前缀最小和消耗，就说明这条线路是合法的（没问题？）。 代码 class Solution: # @param gas, a list of integers # @param cost, a list of integers # @return an integer def canCompleteCircuit(self, gas, cost): len_remain = len(gas) remain = [x for x in gas] for i in range(0, len_remain): remain[i] -= cost[i] total = 0 start = 0 prefix_min = 0 prefix_tot = 0 is_find = False for i in range(0, len_remain): prefix_tot += remain[i] if prefix_tot = 0: is_find = True break return start if is_find else -1 Welcome to my blob Xnerv Surveys "},"candy/":{"url":"candy/","title":"135. Candy","keywords":"","body":"【LeetCode with Python】 135. Candy题目分析代码【LeetCode with Python】 135. Candy tagsstart Hard Problems Greedy tagsstop 题目 原题页面：https://leetcode.com/problems/candy/ 本文地址：http://leetcode.xnerv.wang/candy/ 题目类型：Greedy 难度评价：Hard There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 分析 贪婪法。初始化一个大小为N的数组，元素都是1，表示每个人至少有一个糖果。然后进行两遍贪婪处理： 首先先从左往右遍历，如果一个人的排名高于左侧的人，要比左侧的人多一个糖果。 接着从右往左遍历，如果一个人的排名高于右侧的人，则至少要比右侧的人多一个糖果。当然如果该人的糖果本来就已经比右侧多，就无需多管了。 （有意思的是，如何证明贪婪法得到的是最优解？） 代码 class Solution: # @param ratings, a list of integer # @return an integer def candy(self, ratings): len_r = len(ratings) if len_r ratings[i - 1]: candys[i] = candys[i - 1] + 1 for i in range(len_r - 2, -1, -1): if ratings[i] > ratings[i + 1]: candys[i] = max(candys[i + 1] + 1, candys[i]) return sum(candys) Welcome to my blob Xnerv Surveys "},"single-number/":{"url":"single-number/","title":"136. Single Number","keywords":"","body":"【LeetCode with Python】 136. Single Number题目分析代码【LeetCode with Python】 136. Single Number tagsstart Medium Problems Hash Table Bit Manipulation tagsstop 题目 原题页面：https://leetcode.com/problems/single-number/ 本文地址：http://leetcode.xnerv.wang/single-number/ 题目类型：Medium 难度评价：Hash Table, Bit Manipulation 类似题目：(M) Single Number II, (M) Single Number III, (M) Missing Number, (H) Find the Duplicate Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 分析 编程之美上好像也出现过类似的题目。关键是异或操作（异或支持交换律），知道的人立马能做出来，不知道的人想破脑袋也想不出这个方法。当然用hashmap/map之类的把所有元素插一遍也能找出这个只出现过一次的元素，但是想必面试官不会很开心。位操作还是有很多技巧的，还需要继续深入学习。 此外还可以参考Single Number II。 代码 class Solution: # @param A, a list of integer # @return an integer def singleNumber(self, A): len_A = len(A) if 0 == len_A: return 0 elif 1 == len_A: return A[0] else: result = A[0] for i in range(1, len_A): result ^= A[i] return result Welcome to my blob Xnerv Surveys "},"single-number-ii/":{"url":"single-number-ii/","title":"137. Single Number II","keywords":"","body":"【LeetCode with Python】 137. Single Number II题目分析代码【LeetCode with Python】 137. Single Number II tagsstart Medium Problems Bit Manipulation tagsstop 题目 原题页面：https://oj.leetcode.com/problems/single-number-ii/ 本文地址：http://leetcode.xnerv.wang/single-number-ii/ 题目类型：Bit Manipulation 难度评价：Medium 类似题目：(M) Single Number, (M) Single Number III Given an array of integers, every element appears three times except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 分析 与Single Number相比，前者是每个元素出现两次（除了一个特殊元素），而本题是每个元素出现三次（除了一个特殊元素）。 int数据共有32位，可以用32变量存储这N个元素中各个二进制位上1出现的次数，最后在进行模三操作，如果为1，那说明这一位是要找元素二进制表示中为1的那一位。但是这种做法估计不是最好的，应该有更好的算法，思考中。 代码 class Solution: # @param A, a list of integer # @return an integer def singleNumber(self, A): len_A = len(A) counts = [0] * 32 res = 0 for i in range(0, 32): for num in A: #num = long(num) # it will make time limit exceeded counts[i] += (num>>i) & 1 res |= ((counts[i] % 3) Welcome to my blob Xnerv Surveys "},"copy-list-with-random-pointer/":{"url":"copy-list-with-random-pointer/","title":"138. Copy List with Random Pointer","keywords":"","body":"【LeetCode with Python】 138. Copy List with Random Pointer题目分析代码【LeetCode with Python】 138. Copy List with Random Pointer tagsstart Hard Problems Hash Table Linked List tagsstop 题目 原题页面：https://leetcode.com/problems/copy-list-with-random-pointer/ 本文地址：http://leetcode.xnerv.wang/copy-list-with-random-pointer/ 题目类型：Hash Table, Linked List 难度评价：Hard 类似题目：(M) Clone Graph A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 分析 代码 # Definition for singly-linked list with a random pointer. class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None class Solution: # @param head, a RandomListNode # @return a RandomListNode def copyRandomList(self, head): if None == head: return None save_list = [ ] p1 = head while None != p1: save_list.append(p1) p1 = p1.next new_head = RandomListNode(-1) new_head.next = head first = new_head second = head copy_head = RandomListNode(-1) copy_first = copy_head copy_second = None while None != first: copy_second = RandomListNode(second.label) if None != second else None copy_first.next = copy_second copy_first = copy_first.next first = first.next if None != second: second = second.next p1 = head p1_tail = head.next p2 = copy_head.next while None != p1: p1_tail = p1.next p1.next = p2 p2.random = p1 p1 = p1_tail p2 = p2.next p2 = copy_head.next #p1 = head while None != p2: p2.random = p2.random.random.next if None != p2.random.random else None #p1.next = p1.next.next.random if None != p1.next.next else None # may broken the previous p1.next, so have to save ori list p2 = p2.next #p1 = p1.next len_save_list = len(save_list) for i in range(0, len_save_list - 1): save_list[i].next = save_list[i + 1] save_list[len_save_list - 1].next = None return copy_head.next Welcome to my blob Xnerv Surveys "},"linked-list-cycle/":{"url":"linked-list-cycle/","title":"141. Linked List Cycle","keywords":"","body":"【LeetCode with Python】 141. Linked List Cycle题目分析代码【LeetCode with Python】 141. Linked List Cycle tagsstart Medium Problems Linked List Two Pointers tagsstop 题目 原题页面：https://leetcode.com/problems/linked-list-cycle/ 本文地址：http://leetcode.xnerv.wang/linked-list-cycle/ 题目类型：Linked List, Two Pointers 难度评价：Medium 类似题目：(M) Linked List Cycle II Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 分析 确定链表是否有环。记得好像是编程之美上的题目？ 用两个指针。一个是快指针，每轮走两步。一个是慢指针，每轮走一步。如果链表有环，则总会有某个时刻，快慢指针会相遇在同一个节点。 如何证明呢？假设现在两个指针都已经进入了环，快指针每次都比慢指针多走一步。那么当某个时刻，快指针要么在慢指针后面一个节点处，要么在其后面两个节点处。如果是前者，则下一次两者就会相遇。如果是后者，则下一次走动后，快指针将位于慢指针后面一个节点处，则又回到了前者的情形。所以两个指针必然会相遇到环上的某个节点处。 代码 class Solution: # @param head, a ListNode # @return a boolean def hasCycle(self, head): if None == head: return False fast = slow = head while True: fast = fast.next if None == fast: return False fast = fast.next if None == fast: return False slow = slow.next if fast == slow: return True Welcome to my blob Xnerv Surveys "},"reorder-list/":{"url":"reorder-list/","title":"143. Reorder List","keywords":"","body":"【LeetCode with Python】 143. Reorder List题目分析代码【LeetCode with Python】 143. Reorder List tagsstart Medium Problems Linked List tagsstop 题目 原题页面：https://leetcode.com/problems/reorder-list/ 本文地址：http://leetcode.xnerv.wang/reorder-list/ 题目类型：Linked List 难度评价：Medium Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You must do this in-place without altering the nodes' values. For example, Given {1,2,3,4}, reorder it to {1,4,2,3}. 分析 将链表倒置过来，然后再和原链表进行穿插。是不是有更好的方法？（等等什么情况，没有拷贝原链表就倒置，原本的链表顺序不就被破坏了么？？？） 代码 class Solution: # @param head, a ListNode # @return nothing def reorderList(self, head): if None == head: return cur = head count = 0 while None != cur: cur = cur.next count += 1 if count Welcome to my blob Xnerv Surveys "},"binary-tree-preorder-traversal/":{"url":"binary-tree-preorder-traversal/","title":"144. Binary Tree Preorder Traversal","keywords":"","body":"【LeetCode with Python】 144. Binary Tree Preorder Traversal题目分析代码【LeetCode with Python】 144. Binary Tree Preorder Traversal tagsstart Medium Problems Tree Stack tagsstop 题目 原题页面：https://leetcode.com/problems/binary-tree-preorder-traversal/ 本文地址：http://leetcode.xnerv.wang/binary-tree-preorder-traversal/ 题目类型：Tree, Stack 难度评价：Medium 类似题目：(M) Binary Tree Inorder Traversal, (M) Verify Preorder Sequence in Binary Search Tree Given a binary tree, return the preorder traversal of its nodes' values. For example: Given binary tree {1,#,2,3}, 1 \\ 2 / 3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 分析 非递归前序遍历二叉树。这里是用栈，先右孩子入栈，再左孩子入栈。隐约还记得如果是层次遍历，即需要用队列了。二叉树的非递归遍历中，记得后序遍历是最复杂的，需要用两个栈，以后再复习一下后序遍历。 代码 class Solution: # @param root, a tree node # @return a list of integers def preorderTraversal(self, root): if None == root: return [ ] list = [ ] stack = [ ] cur = root while True: list.append(cur.val) if None != cur.right: stack.append(cur.right) if None != cur.left: stack.append(cur.left) if len(stack) >= 1: cur = stack.pop() else: break return list Welcome to my blob Xnerv Surveys "},"lru-cache/":{"url":"lru-cache/","title":"146. LRU Cache","keywords":"","body":"【LeetCode with Python】 146. LRU Cache题目分析代码【LeetCode with Python】 146. LRU Cache tagsstart Hard Problems Design tagsstop 题目 原题页面：https://leetcode.com/problems/lru-cache/ 本文地址：http://leetcode.xnerv.wang/lru-cache/ 题目类型：Design 难度评价：Hard Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 分析 实现一个LRU缓存。最近最少使用LRU表的定义就不多说了，需要实现的get方法是根据key取value的，因此显然需要一个map，在Python里叫关联数组的帮助。虽然在leetcode中这道题被标为Hard级别，但其实这只是一道工程性质的题目。 另外貌似这道题目的test cases里没有capacity=0的情况？这还是leetcode一贯的作风么？ 代码 class LRUCache: class LRUNode: def __init__(self, key, value): self.prev = None self.next = None self.key = key self.value = value # @param capacity, an integer def __init__(self, capacity): self.map = { } self.list_head = LRUCache.LRUNode(-1, -1) self.list_tail = LRUCache.LRUNode(-1, -1) self.list_head.next = self.list_tail self.list_tail.prev = self.list_head self.capacity = capacity def remove_node(self, node): node.prev.next = node.next node.next.prev = node.prev def append_node(self, new_node): last_node = self.list_tail.prev last_node.next = new_node new_node.prev = last_node new_node.next = self.list_tail self.list_tail.prev = new_node # @return an integer def get(self, key): if self.map.has_key(key): cur = self.map.get(key) self.remove_node(cur) self.append_node(cur) return cur.value else: return -1 # @param key, an integer # @param value, an integer # @return nothing def set(self, key, value): if self.capacity = self.capacity: del_node = self.list_head.next self.remove_node(del_node) del self.map[del_node.key] new_node = LRUCache.LRUNode(key, value) self.append_node(new_node) self.map[key] = new_node Welcome to my blob Xnerv Surveys "},"insertion-sort-list/":{"url":"insertion-sort-list/","title":"147. Insertion Sort List","keywords":"","body":"【LeetCode with Python】 147. Insertion Sort List题目分析代码【LeetCode with Python】 147. Insertion Sort List tagsstart Medium Problems Linked List Sort tagsstop 题目 原题页面：https://leetcode.com/problems/insertion-sort-list/ 本文地址：http://leetcode.xnerv.wang/insertion-sort-list/ 题目类型：Linked List, Sort 难度评价：Medium 类似题目：(M) Sort List Sort a linked list using insertion sort. 分析 链表的插入排序。先是看到网上有人用C++写的解法，生成一个新的链表，每次都将下一个结点插入到这个新链表中，于是用Python仿写之，然超时。后来改成不再生成新链表，而是直接在原链表上原地排序，并且加入了一个判断条件，避免当需要排序的链表已经有序时再做过多无用功（因为前一次超时的原因就是判题系统给了一个超长的已有序链表-_-）。 代码 class Solution: # @param head, a ListNode # @return a ListNode def insertionSortList(self, head): if None == head or None == head.next: return head new_head = ListNode(0) new_head.next = head last = new_head.next cur = new_head.next.next while None != cur: if cur.val >= last.val: last = cur cur = cur.next continue ins = new_head while None != ins.next and ins.next.val Welcome to my blob Xnerv Surveys "},"sort-list/":{"url":"sort-list/","title":"148. Sort List","keywords":"","body":"【LeetCode with Python】 148. Sort List题目分析代码【LeetCode with Python】 148. Sort List tagsstart Medium Problems Linked List Sort tagsstop 题目 原题页面：https://leetcode.com/problems/sort-list/ 本文地址：http://leetcode.xnerv.wang/sort-list/ 题目类型：Linked List, Sort 难度评价：Medium 类似题目：(E) Merge Two Sorted Lists, (M) Sort Colors, (M) Insertion Sort List Sort a linked list in O(n log n) time using constant space complexity. 分析 链表的快速排序。 代码 class Solution: def findMiddle(self, head): slow = head fast = head.next while None != fast and None != fast.next: fast = fast.next.next slow = slow.next return slow def mergeList(self, head): if None == head.next: return head mid = self.findMiddle(head) right_head = mid.next mid.next = None left_list = self.mergeList(head) right_list = self.mergeList(right_head) new_head = ListNode(-1) new_tail = new_head left_node = left_list right_node = right_list while None != left_node and None != right_node: if left_node.val Welcome to my blob Xnerv Surveys "},"max-points-on-a-line/":{"url":"max-points-on-a-line/","title":"149. Max Points on a Line","keywords":"","body":"【LeetCode with Python】 149. Max Points on a Line题目分析代码【LeetCode with Python】 149. Max Points on a Line tagsstart Hard Problems Hash Table Math tagsstop 题目 原题页面：https://leetcode.com/problems/max-points-on-a-line/ 本文地址：http://leetcode.xnerv.wang/max-points-on-a-line/ 题目类型：Hash Table, Math 难度评价：Hard Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 分析 首先要找到newInterval在已有数组中的位置。有三种可能： 这道题比较容易陷入一种思维定势。也就是，大家中学里都学过A，B，C三点共线的判断方法，即判断AB和BC的斜率相等。那么就每次选出两个点，然后去遍历其他点，看是否与这两个点共线，最后找出共线最多的点数。这个算法的时间复杂度是O(n3)。这种每次选三个点的做法，会造成大量的重复比较。从时间复杂度上来看，应该还有其它更好的方法。 更好的方法也就是，每次只挑出一个点，然后遍历其他点，计算与该点形成的斜率，然后统计到相应的map（字典）中，这样复杂度就降低到了O(n2)，因为Python的字典是用Hash表实现，所以理想情况下可以看成插入和查找的时间复杂度为O(1)。 另外，对于选定点A，另外两个共线点B和C是出现在A在同一侧（左侧或右侧），还是出现在不同侧，BA和BC的斜率都是相等的，结合笛卡尔坐标系可以看出这一点。 但是需要特别注意两种特殊点： 与当前考察点重合。这类点可以算入到任何其它斜率的直线上。如A点和B点形成30度斜率，C点和A点重合，那么30度斜率直线上至少就有A，B，C三个点。 与当前考察点垂直。因为这种情况斜率无穷大，dx分母为0，不能进行计算斜率的除法操作，因此要单独计数。 代码 class Solution: # @param points, a list of Points # @return an integer def maxPoints(self, points): len_points = len(points) if len_points max_count: max_count = infinite_count for k, v in gradients.items(): v += duplicate_count if v > max_count: max_count = v return max_count Welcome to my blob Xnerv Surveys "},"evaluate-reverse-polish-notation/":{"url":"evaluate-reverse-polish-notation/","title":"150. Evaluate Reverse Polish Notation","keywords":"","body":"【LeetCode with Python】 150. Evaluate Reverse Polish Notation题目分析代码【LeetCode with Python】 150. Evaluate Reverse Polish Notation tagsstart Medium Problems Stack tagsstop 题目 原题页面：https://leetcode.com/problems/evaluate-reverse-polish-notation/ 本文地址：http://leetcode.xnerv.wang/evaluate-reverse-polish-notation/ 题目类型：Stack 难度评价：Medium 类似题目：(M) Basic Calculator, (H) Expression Add Operators Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Some examples: [\"2\", \"1\", \"+\", \"3\", \"\"] -> ((2 + 1) 3) -> 9 [\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6 分析 逆波兰式（后缀表达式）的计算。相信大多数计算机和软件专业的朋友大学时都做过的算法题，用栈模拟计算过程。 但是从原题给的examples看来的话，题目要求的除法其实是整除，在Python中就是//，在C/C++中就是int/int。 代码 class Solution: # @param tokens, a list of string # @return an integer def evalRPN(self, tokens): len_tokens = len(tokens) if 0 == len_tokens: return 0 # python has no stack, so we have to simulate it nums_stack = [] for i in range(0, len_tokens): token = tokens[i] # consider negative number, so shouldn't decide by the first char, but last char last_ch = token[len(token) - 1] if last_ch >= '0' and last_ch = 0 and right >= 0) or (left Welcome to my blob Xnerv Surveys "},"reverse-words-in-a-string/":{"url":"reverse-words-in-a-string/","title":"151. Reverse Words in a String","keywords":"","body":"【LeetCode with Python】 151. Reverse Words in a String题目分析代码【LeetCode with Python】 151. Reverse Words in a String tagsstart Medium Problems String tagsstop 题目 原题页面：https://leetcode.com/problems/reverse-words-in-a-string/ 本文地址：http://leetcode.xnerv.wang/reverse-words-in-a-string/ 题目类型：Medium 难度评价：String 类似题目：(M) Reverse Words in a String II Given an input string, reverse the string word by word. For example, Given s = \"the sky is blue\", return \"blue is sky the\". Update (2015-02-12): For C programmers: Try to solve it in-place in O(1) space. Clarification: What constitutes a word? A sequence of non-space characters constitutes a word. Could the input string contain leading or trailing spaces? Yes. However, your reversed string should not contain leading or trailing spaces. How about multiple spaces between two words? Reduce them to a single space in the reversed string. 分析 反转一句话中的单词。注意题中还要求去除首尾可能存在的空白字符，词与词之间也要去除多余空白字符，而只留一个空白。 代码 class Solution: # @param s, a string # @return a string def reverseWords(self, s): len_s = len(s) if len_s = 0: while index_right >= 0 and ' ' == s[index_right]: index_right -= 1 end_index = index_right while index_right >= 0 and ' ' != s[index_right]: index_right -= 1 start_index = index_right + 1 word = s[start_index : end_index + 1] if end_index >= 0 else \"\" new_s += (word + \" \") return new_s.rstrip() Welcome to my blob Xnerv Surveys "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Welcome to my blob Xnerv Surveys Medium Problems 1. Two Sum 2. Add Two Numbers 11. Container With Most Water 12. Integer to Roman 17. Letter Combinations of a Phone Number 22. Generate Parentheses 24. Swap Nodes in Pairs 29. Divide Two Integers 35. Search Insert Position 39. Combination Sum 40. Combination Sum II 46. Permutations 47. Permutations II 48. Rotate Image 50. Pow(x, n) 53. Maximum Subarray 54. Spiral Matrix 59. Spiral Matrix II 61. Rotate List 62. Unique Paths 71. Simplify Path 73. Set Matrix Zeroes 75. Sort Colors 77. Combinations 78. Subsets 80. Remove Duplicates from Sorted Array II 82. Remove Duplicates from Sorted List II 86. Partition List 90. Subsets II 91. Decode Ways 92. Reverse Linked List II 93. Restore IP Addresses 94. Binary Tree Inorder Traversal 96. Unique Binary Search Trees 98. Validate Binary Search Tree 108. Convert Sorted Array to Binary Search Tree 113. Path Sum II 114. Flatten Binary Tree to Linked List 116. Populating Next Right Pointers in Each Node 121. Best Time to Buy and Sell Stock 122. Best Time to Buy and Sell Stock II 129. Sum Root to Leaf Numbers 134. Gas Station 136. Single Number 137. Single Number II 141. Linked List Cycle 143. Reorder List 144. Binary Tree Preorder Traversal 147. Insertion Sort List 148. Sort List 150. Evaluate Reverse Polish Notation 151. Reverse Words in a String Array 1. Two Sum 4. Median of Two Sorted Arrays 11. Container With Most Water 26. Remove Duplicates from Sorted Array 27. Remove Element 33. Search in Rotated Sorted Array 35. Search Insert Position 39. Combination Sum 40. Combination Sum II 42. Trapping Rain Water 48. Rotate Image 53. Maximum Subarray 54. Spiral Matrix 56. Merge Intervals 57. Insert Interval 59. Spiral Matrix II 62. Unique Paths 66. Plus One 73. Set Matrix Zeroes 75. Sort Colors 78. Subsets 80. Remove Duplicates from Sorted Array II 88. Merge Sorted Array 90. Subsets II 118. Pascal's Triangle 119. Pascal's Triangle II 121. Best Time to Buy and Sell Stock 122. Best Time to Buy and Sell Stock II 128. Longest Consecutive Sequence Hash Table 1. Two Sum 94. Binary Tree Inorder Traversal 136. Single Number 138. Copy List with Random Pointer 149. Max Points on a Line Linked List 2. Add Two Numbers 19. Remove Nth Node From End of List 21. Merge Two Sorted Lists 24. Swap Nodes in Pairs 61. Rotate List 82. Remove Duplicates from Sorted List II 83. Remove Duplicates from Sorted List 86. Partition List 92. Reverse Linked List II 138. Copy List with Random Pointer 141. Linked List Cycle 143. Reorder List 147. Insertion Sort List 148. Sort List Math 2. Add Two Numbers 7. Reverse Integer 8. String to Integer (atoi) 9. Palindrome Number 12. Integer to Roman 13. Roman to Integer 29. Divide Two Integers 50. Pow(x, n) 65. Valid Number 66. Plus One 67. Add Binary 149. Max Points on a Line Hard Problems 4. Median of Two Sorted Arrays 10. Regular Expression Matching 33. Search in Rotated Sorted Array 42. Trapping Rain Water 44. Wildcard Matching 51. N-Queens 52. N-Queens II 56. Merge Intervals 57. Insert Interval 65. Valid Number 72. Edit Distance 97. Interleaving String 117. Populating Next Right Pointers in Each Node II 124. Binary Tree Maximum Path Sum 128. Longest Consecutive Sequence 135. Candy 138. Copy List with Random Pointer 146. LRU Cache 149. Max Points on a Line Divide and Conquer 4. Median of Two Sorted Arrays 53. Maximum Subarray Binary Search 4. Median of Two Sorted Arrays 29. Divide Two Integers 33. Search in Rotated Sorted Array 50. Pow(x, n) todo 4. Median of Two Sorted Arrays 117. Populating Next Right Pointers in Each Node II Easy Problems 6. ZigZag Conversion 7. Reverse Integer 8. String to Integer (atoi) 9. Palindrome Number 13. Roman to Integer 14. Longest Common Prefix 19. Remove Nth Node From End of List 20. Valid Parentheses 21. Merge Two Sorted Lists 26. Remove Duplicates from Sorted Array 27. Remove Element 38. Count and Say 58. Length of Last Word 66. Plus One 67. Add Binary 70. Climbing Stairs 83. Remove Duplicates from Sorted List 88. Merge Sorted Array 100. Same Tree 101. Symmetric Tree 102. Binary Tree Level Order Traversal 104. Maximum Depth of Binary Tree 107. Binary Tree Level Order Traversal II 110. Balanced Binary Tree 111. Minimum Depth of Binary Tree 112. Path Sum 118. Pascal's Triangle 119. Pascal's Triangle II 125. Valid Palindrome String 6. ZigZag Conversion 8. String to Integer (atoi) 10. Regular Expression Matching 12. Integer to Roman 13. Roman to Integer 14. Longest Common Prefix 17. Letter Combinations of a Phone Number 20. Valid Parentheses 22. Generate Parentheses 38. Count and Say 44. Wildcard Matching 58. Length of Last Word 65. Valid Number 67. Add Binary 71. Simplify Path 72. Edit Distance 91. Decode Ways 93. Restore IP Addresses 97. Interleaving String 125. Valid Palindrome 151. Reverse Words in a String Dynamic Programming 10. Regular Expression Matching 44. Wildcard Matching 53. Maximum Subarray 62. Unique Paths 70. Climbing Stairs 72. Edit Distance 91. Decode Ways 96. Unique Binary Search Trees 97. Interleaving String 121. Best Time to Buy and Sell Stock Backtracking 10. Regular Expression Matching 17. Letter Combinations of a Phone Number 22. Generate Parentheses 39. Combination Sum 40. Combination Sum II 44. Wildcard Matching 46. Permutations 47. Permutations II 51. N-Queens 52. N-Queens II 77. Combinations 78. Subsets 90. Subsets II 93. Restore IP Addresses Two Pointers 11. Container With Most Water 19. Remove Nth Node From End of List 26. Remove Duplicates from Sorted Array 27. Remove Element 42. Trapping Rain Water 61. Rotate List 75. Sort Colors 80. Remove Duplicates from Sorted Array II 86. Partition List 88. Merge Sorted Array 125. Valid Palindrome 141. Linked List Cycle Stack 20. Valid Parentheses 42. Trapping Rain Water 71. Simplify Path 94. Binary Tree Inorder Traversal 144. Binary Tree Preorder Traversal 150. Evaluate Reverse Polish Notation Binary 35. Search Insert Position Greedy 44. Wildcard Matching 122. Best Time to Buy and Sell Stock II 134. Gas Station 135. Candy Sort 56. Merge Intervals 57. Insert Interval 75. Sort Colors 147. Insertion Sort List 148. Sort List Bit Manipulation 78. Subsets 136. Single Number 137. Single Number II Tree 94. Binary Tree Inorder Traversal 96. Unique Binary Search Trees 98. Validate Binary Search Tree 100. Same Tree 101. Symmetric Tree 102. Binary Tree Level Order Traversal 104. Maximum Depth of Binary Tree 107. Binary Tree Level Order Traversal II 108. Convert Sorted Array to Binary Search Tree 110. Balanced Binary Tree 111. Minimum Depth of Binary Tree 112. Path Sum 113. Path Sum II 114. Flatten Binary Tree to Linked List 116. Populating Next Right Pointers in Each Node 117. Populating Next Right Pointers in Each Node II 124. Binary Tree Maximum Path Sum 129. Sum Root to Leaf Numbers 144. Binary Tree Preorder Traversal Depth-first Search 98. Validate Binary Search Tree 100. Same Tree 101. Symmetric Tree 104. Maximum Depth of Binary Tree 108. Convert Sorted Array to Binary Search Tree 110. Balanced Binary Tree 111. Minimum Depth of Binary Tree 112. Path Sum 113. Path Sum II 114. Flatten Binary Tree to Linked List 116. Populating Next Right Pointers in Each Node 117. Populating Next Right Pointers in Each Node II 124. Binary Tree Maximum Path Sum 129. Sum Root to Leaf Numbers Breadth-first Search 102. Binary Tree Level Order Traversal 107. Binary Tree Level Order Traversal II 111. Minimum Depth of Binary Tree Design 146. LRU Cache "}}